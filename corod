--OPTIONS

local a = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Accessory"):Clone()
a.Parent = game:GetService("Players").LocalPlayer.Character
a.Name = "poggers"
a.Handle.Transparency = 1

local a = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Accessory"):Clone()
a.Parent = game:GetService("Players").LocalPlayer.Character
a.Name = "aesword"
a.Handle.Transparency = 1

local a = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Accessory"):Clone()
a.Parent = game:GetService("Players").LocalPlayer.Character
a.Name = "uhyes"
a.Handle.Transparency = 1

local a = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Accessory"):Clone()
a.Parent = game:GetService("Players").LocalPlayer.Character
a.Name = "swordlol"
a.Handle.Transparency = 1

local a = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Accessory"):Clone()
a.Parent = game:GetService("Players").LocalPlayer.Character
a.Name = "swordhalo"
a.Handle.Transparency = 1

local a = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Accessory"):Clone()
a.Parent = game:GetService("Players").LocalPlayer.Character
a.Name = "Auragamer"
a.Handle.Transparency = 1



game:GetService("Players").LocalPlayer.Character["DemonGodSword"].Name = "swordlol"

game:GetService("Players").LocalPlayer.Character["RainbowGodSword"].Name = "uhyes"

game:GetService("Players").LocalPlayer.Character["AuroraSword"].Name = "aesword"

game:GetService("Players").LocalPlayer.Character["VoidLordSword"].Name = "poggers"

game.Players.LocalPlayer.Character.swordlol.Handle.Size= Vector3.new(0.1,0.1,0.1)

game.Players.LocalPlayer.Character.uhyes.Handle.Size= Vector3.new(0.1,0.1,0.1)

game.Players.LocalPlayer.Character.aesword.Handle.Size= Vector3.new(0.1,0.1,0.1)

game.Players.LocalPlayer.Character.poggers.Handle.Size= Vector3.new(0.1,0.1,0.1)

game.Players.LocalPlayer.Character.swordhalo.Handle.Size= Vector3.new(0.1,0.1,0.1)

game.Players.LocalPlayer.Character.DemonLordSword.Handle.Size= Vector3.new(0.1,0.1,0.1)

game.Players.LocalPlayer.Character.CorruptLordSword.Handle.Size= Vector3.new(0.1,0.1,0.1)

game.Players.LocalPlayer.Character.Auragamer.Handle.Size= Vector3.new(0.1,0.1,0.1)



local startmode = "Meow's Glitcher; made by MeowldarkXD/Olie#4559"

--Message that appears in chat
local chatmsg = true 
local msgtext = "Meow's Glitcher | Credits to Herliebe for fixing the reanim." 
local Color = "Really red"


local qna = false
local sidalarm = false
--Owners note of the sg
local ownernote = true
local ownertext = "WHY AM I DOING SPECTRUM?"
local Color2 = "Really black"

-- Screen Text GUI
local screenmsg = false 
local screentext = "Fake Loading Screen Nerd!" 

-- Other settings
local voicelines = false 

print('How to find keys: Click CTRL + F And Search the word "Key" Then look at the mode name the button that says Enum.KeyCode.KeyCode And Where keycode is in this line is where the key should be in the actual script | Newest mode is extinction | Why do it be printing reset in console :Thinking | Dont do drugs unless perscribed | Wow v12 Of this? I must have no life |')


if chatmsg == true then
bc = BrickColor.new(Color)
game.StarterGui:SetCore("ChatMakeSystemMessage", {
    Text = msgtext;
    Font = Enum.Font.SourceSansItalic;
    Color = bc.Color;
    FontSize = Enum.FontSize.Size96;    
})
else
end

if qna == true then
game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Q & A]: Q: IS this an achro? A: Yes it indeed is", "All")
game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Q & A]: Q: Can i have this script? A: No, I dont want skids using my work and saying its theirs", "All")
game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Q & A]: Q: Will you ever sell this script? A: I would have to think on that.", "All")
else
end

if skidalarm == true then
game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Meow's Glitcher]: REAL fe Glitcher  by meowldarkXD", "All")
else
end

if ownernote == true then
bc = BrickColor.new(Color2)
game.StarterGui:SetCore("ChatMakeSystemMessage", {
    Text = ownertext;
    Font = Enum.Font.Bodoni;
    Color = bc.Color;
    FontSize = Enum.FontSize.Size96;    
})
else
end

if screenmsg == true then
local message = Instance.new("Message")
message.Parent = game.Workspace
message.Text = screentext
wait(2)
message:Remove()
else
end

    game:GetService("StarterGui"):SetCore("SendNotification", { 
	Title = "Credits";
	Text = "Credits to Herliebe for fixing the reanim.";
	Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"});
Duration = 16;

game:GetService("StarterGui"):SetCore("SendNotification", { 
	Title = "Version";
	Text = "Version v11.6, A New Era";
	Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"});
	Button1 = "Enjoy"
Duration = 16;




--- DO NOT PUT NORMAL ANIMATION
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
game:GetService("RunService").Heartbeat:connect(function()
v.Velocity = Vector3.new(math.random(30,31),0,0)
end)
end
end

Bypass = "death"
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
loadstring(game:GetObjects("rbxassetid://9295055645")[1].Source)()    

plr = game.Players.LocalPlayer
dead = false
char = plr.Character

bullet = workspace[plr.Name]["HumanoidRootPart"]
bullet.Transparency = 0.5
bhandle = bullet
bullet.Massless = true
bullet:FindFirstChildOfClass("Attachment"):Destroy()
bullet:FindFirstChildOfClass("Attachment"):Destroy()
bullet:FindFirstChildOfClass("Attachment"):Destroy()



bbav = Instance.new("BodyAngularVelocity",bullet)
    bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
    bbav.P = 100000000000000000000000000
    bbav.AngularVelocity = Vector3.new(100000000000000000000000000,100000000000000000000000000,100000000000000000)

local CDDF = {}
local DamageFling = function(DmgPer)
    if Fling ~= true then return end
    if IsDead or Bypass ~= "death" or (DmgPer.Name == playerss.Name and DmgPer.Name == "non") or CDDF[DmgPer] or not DmgPer or not DmgPer:FindFirstChildOfClass("Humanoid") or DmgPer:FindFirstChildOfClass("Humanoid").Health <= 0 then return end
    CDDF[DmgPer] = true; StateMover = false
    local PosFling = (DmgPer:FindFirstChild("HumanoidRootPart") and DmgPer:FindFirstChild("HumanoidRootPart") .CFrame.p) or (DmgPer:FindFirstChildOfClass("Part") and DmgPer:FindFirstChildOfClass("Part").CFrame.p)
    bullet.Rotation = playerss.Torso.Rotation
    bbav = Instance.new("BodyAngularVelocity",bullet)
    bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
    bbav.P = 100000000000000000000000000000
    bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)

    for _=1,15 do
        bbv.Position = PosFling
        bullet.Position = PosFling
        wait(0.03)
    end
    bbav:Destroy()
    bbv.Position = playerss.Torso.CFrame.p
    bullet.Position = playerss.Torso.CFrame.p
    CDDF[DmgPer] = false; StateMover = true
end


 spawn(
    function()
        while true do
            game:GetService("RunService").Heartbeat:Wait()
            bullet.Velocity = Vector3.new(-15,15,15)
     end
end)

spawn(
    function()
        while true do
            game:GetService("RunService").Heartbeat:Wait()
            bullet.Position = game.Players.LocalPlayer.Character.Torso.Position
     end
end)



local data = {}



	local data = {}

	local script = game:GetObjects("rbxassetid://5446036971")[1]

	script.WingPiece.qPerfectionWeld:Destroy()

	do
		local NEVER_BREAK_JOINTS = false

		local function CallOnChildren(Instance, FunctionToCall)
			FunctionToCall(Instance)

			for _, Child in next, Instance:GetChildren() do
				CallOnChildren(Child, FunctionToCall)
			end
		end

		local function GetBricks(StartInstance)
			local List = {}
			CallOnChildren(StartInstance, function(Item)
				if Item:IsA("BasePart") then
					List[#List+1] = Item;
				end
			end)

			return List
		end

		local function Modify(Instance, Values)
			assert(type(Values) == "table", "Values is not a table");

			for Index, Value in next, Values do
				if type(Index) == "number" then
					Value.Parent = Instance
				else
					Instance[Index] = Value
				end
			end
			return Instance
		end

		local function Make(ClassType, Properties)
			return Modify(Instance.new(ClassType), Properties)
		end

		local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
		local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

		local function HasWheelJoint(Part)
			for _, SurfaceName in pairs(Surfaces) do
				for _, HingSurfaceName in pairs(HingSurfaces) do
					if Part[SurfaceName].Name == HingSurfaceName then
						return true
					end
				end
			end

			return false
		end

		local function ShouldBreakJoints(Part)
			if NEVER_BREAK_JOINTS then
				return false
			end

			if HasWheelJoint(Part) then
				return false
			end

			local Connected = Part:GetConnectedParts()

			if #Connected == 1 then
				return false
			end

			for _, Item in pairs(Connected) do
				if HasWheelJoint(Item) then
					return false
				elseif not Item:IsDescendantOf(script.Parent) then
					return false
				end
			end

			return true
		end

		local function WeldTogether(Part0, Part1, JointType, WeldParent)

			JointType = JointType or "Weld"
			local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")

			local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
			Modify(NewWeld, {
				Name = "qCFrameWeldThingy";
				Part0  = Part0;
				Part1  = Part1;
				C0     = CFrame.new();--Part0.CFrame:inverse();
				C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
				Parent = Part1;
			})

			if not RelativeValue then
				RelativeValue = Make("CFrameValue", {
					Parent     = Part1;
					Name       = "qRelativeCFrameWeldValue";
					Archivable = true;
					Value      = NewWeld.C1;
				})
			end

			return NewWeld
		end

		local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)

			for _, Part in pairs(Parts) do
				if ShouldBreakJoints(Part) then
					Part:BreakJoints()
				end
			end

			for _, Part in pairs(Parts) do
				if Part ~= MainPart then
					WeldTogether(MainPart, Part, JointType, MainPart)
				end
			end

			if not DoNotUnanchor then
				for _, Part in pairs(Parts) do
					Part.Anchored = false
				end
				MainPart.Anchored = false
			end
		end

		local function PerfectionWeld()	
			local Parts = GetBricks(script.WingPiece)
			WeldParts(Parts, script.WingPiece.Main, "Weld", false)
		end
		PerfectionWeld()
	end

	--// Shortcut Variables \\--
	local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
	local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
	local C3 = {tRGB= function(c3) return c3.r*255,c3.g*255,c3.b*255 end,N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
	local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
	local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
	local R3 = {N=Region3.new}
	local De = S.Debris
	local WS = workspace
	local Lght = S.Lighting
	local RepS = S.ReplicatedStorage
	local IN = Instance.new
	local Plrs = S.Players
	local UIS = S.UserInputService

	local Player = game.Players.LocalPlayer
	data.User = Player
	data.Local = Player
	local Char = workspace.non
	local Mouse = Player:GetMouse()
	local Hum = Char:FindFirstChildOfClass'Humanoid'
	local Torso = Char.Torso
	local RArm = Char["Right Arm"]
	local LArm = Char["Left Arm"]
	local RLeg = Char["Right Leg"]
	local LLeg = Char["Left Leg"]	
	local Root = Char:FindFirstChild'HumanoidRootPart'
	local Head = Char.Head
	local Sine = 0;
	local Change = 1
	local Attack=false
	local NeutralAnims=true
	local timePos=30;
	local walking=true;
	local legAnims=true;
	local movement = 8
	local footsound=0;
	local WalkSpeed=16;
	local Combo=0;
	local Mode='APEX'
	local vaporwaveMode=false;
	local WingAnim='KRAZY'
	local music;
	local hue = 0;
	local WingSine=0;
	local MusicMode=1;
	local visSong = 6819593773;
	local EffectFolder = script:WaitForChild'FXFolder'
	local PrimaryColor = Color3.new(1,1,1)
	local ClickTimer = 0;
	local ClickAttack = 1;
	local camera = workspace.CurrentCamera
	local LastSphere = time();
	local Frame_Speed = 60
	local VaporwaveSongs={
		2231500330;
		654094806;
		743334292;
		334283059;
		2082142910;
	}


	local WingPiece = script:WaitForChild'WingPiece'
	WingPiece.Parent=nil
	local WingAnims={}
	local Playlist={
		Default=1702473314;
		ScrapBoy=1215691669;
		Defeated=860594509;
		Annihilate=2116461106;
		DashAndDodge=2699922745;
		ZenWavy=2231500330;
		Beachwalk=334283059;
		Pyrowalk=2082142910;
		Vapor90s=654094806;
	}





	
	
	

--[[
Achromatic - The Big Black - Lost Soul
Iniquitous
Mythical - Legendary
Ruined - Th1rt3en
Atramentous - Vanta Black
Subzero - Frostbite
Troubadour
Infectious - Radioactive
Love - Lust
]]
	-- 
	local modeInfo={  --4550046224rbxassetid://6149743293

{Name="Forgotten",Walkspeed=40,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.RGB(40, 0, 0);Music=1838974004,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='Cytus125'};
{Name="CHOICE",Walkspeed=35,moveVal=10,Font=Enum.Font.Bodoni,StrokeColor=C3.RGB(255, 0, 105);Music=1841634850,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='JUDGEMENT'};
{Name="サイコ",Walkspeed=200,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.RGB(255, 0, 105);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='JUDGEMENT'};
{Name="COLLAPSED",Walkspeed=80,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.RGB(255, 0, 105);Music=9046863579,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='JUDGEMENT'};
{Name="ERR0R",Walkspeed=300,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.RGB(255, 0, 105);Music=1842652230,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='JUDGEMENT'};
{Name="WARP",Walkspeed=30,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.RGB(255, 0, 105);Music=1845805363,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='WARPER'};
{Name="CORROSION",Walkspeed=50,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.RGB(255, 0, 105);Music=1837042739,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='JUDGEMENT'};
{Name="FLAME",Walkspeed=50,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.RGB(255, 0, 255);Music=1842559618,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='JUDGEMENT'};
{Name="PSYCHIC",Walkspeed=50,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.RGB(255, 0, 105);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PSYCHIC'};
{Name="REPRECAUTION",Walkspeed=40,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.RGB(40, 0, 0);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='Cytus125'};
{Name="XENOPHERIC",Walkspeed=80,moveVal=10,Font=Enum.Font.IndieFlower,StrokeColor=C3.RGB(255, 105, 0);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PSYCHIC'};
{Name="P A I N",Walkspeed=12,moveVal=10,Font=Enum.Font.IndieFlower,StrokeColor=C3.RGB(255, 0, 0);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PSYCHIC'};
{Name="DARK",Walkspeed=30,moveVal=10,Font=Enum.Font.IndieFlower,StrokeColor=C3.RGB(255, 0, 0);Music=6819593773,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PSYCHIC'};
{Name="CONTROLLED",Walkspeed=65,moveVal=10,Font=Enum.Font.IndieFlower,StrokeColor=C3.RGB(255, 0, 255);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PSYCHIC'};
{Name="LOST",Walkspeed=65,moveVal=10,Font=Enum.Font.IndieFlower,StrokeColor=C3.RGB(255, 0, 255);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PSYCHIC'};
{Name="CRAZED",Walkspeed=65,moveVal=10,Font=Enum.Font.SpecialElite,StrokeColor=C3.RGB(173, 216, 230);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PSYCHIC'};
{Name="EARTHQUAKE",Walkspeed=65,moveVal=10,Font=Enum.Font.SpecialElite,StrokeColor=C3.RGB(173, 216, 230);Music=9041932535,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PSYCHIC'};
{Name="NEAR DEATH",Walkspeed=30,moveVal=10,Font=Enum.Font.SpecialElite,StrokeColor=C3.RGB(173, 0, 230);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PSYCHIC'};
{Name="CORRODE",Walkspeed=30,moveVal=10,Font=Enum.Font.SpecialElite,StrokeColor=C3.RGB(173, 0, 230);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PSYCHIC'};
{Name="LEXUS ERR0R",Walkspeed=30,moveVal=10,Font=Enum.Font.SpecialElite,StrokeColor=C3.RGB(173, 0, 230);Music=6819593773,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='PSYCHIC'};
{Name="V E L D U S",Walkspeed=30,moveVal=10,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(255, 0, 0);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='VELDUS'};
{Name="C O M P L E X",Walkspeed=30,moveVal=10,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 255, 255);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='VELDUS'};
{Name="F A L L E N",Walkspeed=30,moveVal=10,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 255, 255);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='VELDUS'};
{Name="Damaged",Walkspeed=30,moveVal=10,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 255, 255);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='KRAZY'};
{Name="APEX",Walkspeed=30,moveVal=10,Font=Enum.Font.SpecialElite,StrokeColor=C3.RGB(255, 0, 0);Music=6819593773,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='KRAZY'};
{Name="VIRTUE",Walkspeed=30,moveVal=10,Font=Enum.Font.SourceSans,StrokeColor=C3.RGB(0, 0, 0);Music=1837301393,LeftWing={55,BrickColor.new'Bright blue'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Bright blue'.Color,Enum.Material.Neon};WingAnim='KRAZY'};	
{Name="REDEMPTION",Walkspeed=30,moveVal=10,Font=Enum.Font.SpecialElite,StrokeColor=C3.RGB(0, 255, 255);Music=8420609252,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='Sword1'};
{Name="SANCTUARY",Walkspeed=40,moveVal=10,Font=Enum.Font.SourceSans,StrokeColor=C3.RGB(100, 0, 255);Music=1837301393,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='KRAZY2'};
{Name="EMPERATOR",Walkspeed=250,moveVal=10,Font=Enum.Font.Antique,StrokeColor=C3.RGB(255, 0, 0);Music=9046863579,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='JUDGEMENT'};
{Name="Eradicating",Walkspeed=30,moveVal=10,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(255, 0, 0);Music=9047128953,LeftWing={55,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='JUDGEMENT'};
{Name="GLITCHED",Walkspeed=120,moveVal=10,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(255, 0, 0);Music=6819593773,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='Archsword'};	    
{Name="Expitition",Walkspeed=120,moveVal=10,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 0, 255);Music=6819593773,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='KRAZY2'};	
{Name="Pyro",Walkspeed=120,moveVal=10,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(0, 255, 255);Music=6819593773,LeftWing={55,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={22,BrickColor.new'Really black'.Color,Enum.Material.Neon};WingAnim='Archsword'};	        


	}
	
	
	
	

-- Gui to Lua
-- Version: 3.2

-- Instances:

local coolscript = Instance.new("ScreenGui")
local gaming = Instance.new("Frame")
local PRIMARY = Instance.new("Frame")
local square = Instance.new("Frame")
local SECONDARY = Instance.new("Frame")
local star = Instance.new("ImageLabel")
local smallcircle = Instance.new("ImageLabel")
local bigcircle = Instance.new("ImageLabel")
local bigcirc2 = Instance.new("ImageLabel")
local GLOW2 = Instance.new("ImageLabel")
local smallcirc = Instance.new("ImageLabel")
local SGNAME = Instance.new("TextLabel")
local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
local MODELABEL = Instance.new("TextLabel")
local UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint")
local square2 = Instance.new("Frame")
local SGNAME_2 = Instance.new("TextLabel")
local UITextSizeConstraint_3 = Instance.new("UITextSizeConstraint")
local SGNAME_3 = Instance.new("TextLabel")
local UITextSizeConstraint_4 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
local midcirclebig = Instance.new("ImageLabel")
local midcirclesmal = Instance.new("ImageLabel")

--Properties:

coolscript.Name = "coolscript"
coolscript.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
coolscript.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

gaming.Name = "gaming"
gaming.Parent = coolscript
gaming.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
gaming.BackgroundTransparency = 1.000
gaming.Position = UDim2.new(0, 0, 0.445989311, 0)
gaming.Size = UDim2.new(0.0716353133, 0, 0.105729125, 0)

PRIMARY.Name = "PRIMARY"
PRIMARY.Parent = gaming
PRIMARY.AnchorPoint = Vector2.new(0.5, 0.5)
PRIMARY.BackgroundColor3 = Color3.fromRGB(50, 0, 0)
PRIMARY.BackgroundTransparency = 0.600
PRIMARY.Position = UDim2.new(6.71679068, 0, 4.12718487, 0)
PRIMARY.Size = UDim2.new(47.1793861, 0, 0.799136221, 0)

square.Name = "square"
square.Parent = gaming
square.AnchorPoint = Vector2.new(0.5, 0.5)
square.BackgroundColor3 = Color3.fromRGB(95, 0, 0)
square.BackgroundTransparency = 0.600
square.Position = UDim2.new(6.71679068, 120, 4.13730049, 0)
square.Size = UDim2.new(1.2846874, 0, 1.26445603, 0)

SECONDARY.Name = "SECONDARY"
SECONDARY.Parent = gaming
SECONDARY.AnchorPoint = Vector2.new(0.5, 0.5)
SECONDARY.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
SECONDARY.BackgroundTransparency = 0.600
SECONDARY.Position = UDim2.new(6.70667505, 0, 4.13730049, 0)
SECONDARY.Size = UDim2.new(47.1793861, 0, 0.576591969, 0)

star.Name = "star"
star.Parent = gaming
star.AnchorPoint = Vector2.new(0.5, 0.5)
star.BackgroundColor3 = Color3.fromRGB(58, 0, 0)
star.BackgroundTransparency = 1.000
star.Position = UDim2.new(12.7861795, 230, 4.30926609, 0)
star.Size = UDim2.new(6.19077682, 0, 6.20089245, 0)
star.Image = "http://www.roblox.com/asset/?id=2288843651"
star.ImageColor3 = Color3.fromRGB(47, 0, 0)

smallcircle.Name = "smallcircle"
smallcircle.Parent = gaming
smallcircle.AnchorPoint = Vector2.new(0.5, 0.5)
smallcircle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
smallcircle.BackgroundTransparency = 1.000
smallcircle.Position = UDim2.new(12.371438, 230, 3.90464044, 0)
smallcircle.Size = UDim2.new(5.35117817, 0, 5.37140942, 0)
smallcircle.Image = "http://www.roblox.com/asset/?id=7150932717"
smallcircle.ImageColor3 = Color3.fromRGB(255, 0, 105)

bigcircle.Name = "bigcircle"
bigcircle.Parent = gaming
bigcircle.AnchorPoint = Vector2.new(0.5, 0.5)
bigcircle.BackgroundColor3 = Color3.fromRGB(97, 0, 0)
bigcircle.BackgroundTransparency = 1.000
bigcircle.Position = UDim2.new(12.7861795, 230, 4.30926609, 0)
bigcircle.Size = UDim2.new(6.19077682, 0, 6.20089245, 0)
bigcircle.Image = "http://www.roblox.com/asset/?id=6900421398"
bigcircle.ImageColor3 = Color3.fromRGB(255, 0, 105)

bigcirc2.Name = "bigcirc2"
bigcirc2.Parent = gaming
bigcirc2.AnchorPoint = Vector2.new(0.5, 0.5)
bigcirc2.BackgroundColor3 = Color3.fromRGB(97, 0, 0)
bigcirc2.BackgroundTransparency = 1.000
bigcirc2.Position = UDim2.new(12.7861795, 230, 4.30926609, 0)
bigcirc2.Size = UDim2.new(6.19077682, 0, 6.20089245, 0)
bigcirc2.Image = "http://www.roblox.com/asset/?id=7150933366"
bigcirc2.ImageColor3 = Color3.fromRGB(255, 0, 105)

GLOW2.Name = "GLOW2"
GLOW2.Parent = gaming
GLOW2.AnchorPoint = Vector2.new(0.5, 0.5)
GLOW2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
GLOW2.BackgroundTransparency = 1.000
GLOW2.Position = UDim2.new(12.3613224, 230, 3.90464044, 0)
GLOW2.Size = UDim2.new(3.69221187, 0, 3.72255874, 0)
GLOW2.Image = "http://www.roblox.com/asset/?id=4341732590"
GLOW2.ImageColor3 = Color3.fromRGB(255, 0, 105)

smallcirc.Name = "smallcirc"
smallcirc.Parent = gaming
smallcirc.AnchorPoint = Vector2.new(0.5, 0.5)
smallcirc.BackgroundColor3 = Color3.fromRGB(97, 0, 0)
smallcirc.BackgroundTransparency = 1.000
smallcirc.Position = UDim2.new(12.7659483, 230, 4.30926609, 0)
smallcirc.Size = UDim2.new(3.59105515, 0, 3.62140226, 0)
smallcirc.Image = "http://www.roblox.com/asset/?id=6900421398"
smallcirc.ImageColor3 = Color3.fromRGB(255, 0, 105)

SGNAME.Name = "SGNAME'"
SGNAME.Parent = gaming
SGNAME.AnchorPoint = Vector2.new(0.5, 0.5)
SGNAME.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SGNAME.BackgroundTransparency = 1.000
SGNAME.Position = UDim2.new(1.11272132, 0, 3.45955181, 0)
SGNAME.Size = UDim2.new(2.0231297, 0, 0.505782425, 0)
SGNAME.Font = Enum.Font.Oswald
SGNAME.Text = "corroded glitcher"
SGNAME.TextColor3 = Color3.fromRGB(255, 0, 105)
SGNAME.TextScaled = true
SGNAME.TextSize = 45.000
SGNAME.TextWrapped = true

UITextSizeConstraint.Parent = SGNAME
UITextSizeConstraint.MaxTextSize = 45

SGNAME.Name = "SGNAME'"
SGNAME.Parent = gaming
SGNAME.AnchorPoint = Vector2.new(0.5, 0.5)
SGNAME.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SGNAME.BackgroundTransparency = 1.000
SGNAME.Position = UDim2.new(1.11272132, 1, 3.45955181, 0)
SGNAME.Size = UDim2.new(2.0231297, 0, 0.505782425, 0)
SGNAME.Font = Enum.Font.SpecialElite
SGNAME.Text = "MODE G"
SGNAME.TextColor3 = Color3.fromRGB(255, 0, 105)
SGNAME.TextScaled = true
SGNAME.TextSize = 45.000
SGNAME.TextWrapped = true

UITextSizeConstraint.Parent = SAGNAME
UITextSizeConstraint.MaxTextSize = 45


MODELABEL.Name = "MODELABEL"
MODELABEL.Parent = gaming
MODELABEL.AnchorPoint = Vector2.new(0.5, 0.5)
MODELABEL.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MODELABEL.BackgroundTransparency = 1.000
MODELABEL.Position = UDim2.new(6.67632818, 120, 4.14741611, 0)
MODELABEL.Size = UDim2.new(1.94220459, 0, 0.546245039, 0)
MODELABEL.Font = Enum.Font.SpecialElite
MODELABEL.Text = "CORRODED"
MODELABEL.TextColor3 = Color3.fromRGB(255, 0, 105)
MODELABEL.TextSize = 100.000

UITextSizeConstraint_2.Parent = MODELABEL
UITextSizeConstraint_2.MaxTextSize = 45

square2.Name = "square2"
square2.Parent = gaming
square2.AnchorPoint = Vector2.new(0.5, 0.5)
square2.BackgroundColor3 = Color3.fromRGB(95, 0, 0)
square2.BackgroundTransparency = 0.600
square2.Position = UDim2.new(6.71679068, 120, 4.12718487, 0)
square2.Size = UDim2.new(0.819367528, 0, 0.799136221, 0)

SGNAME_2.Name = "SGNAME'"
SGNAME_2.Parent = gaming
SGNAME_2.AnchorPoint = Vector2.new(0.5, 0.5)
SGNAME_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SGNAME_2.BackgroundTransparency = 1.000
SGNAME_2.Position = UDim2.new(1.11272132, 0, 1.45955181, 0)
SGNAME_2.Size = UDim2.new(2.0231297, 0, 0.505782425, 0)
SGNAME_2.Font = Enum.Font.SpecialElite
SGNAME_2.Text = "MODE H"
SGNAME_2.TextColor3 = Color3.fromRGB(255, 0, 105)
SGNAME_2.TextScaled = true
SGNAME_2.TextSize = 45.000
SGNAME_2.TextWrapped = true

UITextSizeConstraint_3.Parent = SGNAME_2
UITextSizeConstraint_3.MaxTextSize = 50

SGNAME_3.Name = "SGNAME'"
SGNAME_3.Parent = gaming
SGNAME_3.AnchorPoint = Vector2.new(0.5, 0.5)
SGNAME_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SGNAME_3.BackgroundTransparency = 1.000
SGNAME_3.Position = UDim2.new(1.11272132, 0, 4.67342949, 0)
SGNAME_3.Size = UDim2.new(2.0231297, 0, 0.505782425, 0)
SGNAME_3.Font = Enum.Font.Oswald
SGNAME_3.Text = "CORRODED GLITCHER"
SGNAME_3.TextColor3 = Color3.fromRGB(255, 0, 105)
SGNAME_3.TextScaled = true
SGNAME_3.TextSize = 45.000
SGNAME_3.TextWrapped = true

UITextSizeConstraint_4.Parent = SGNAME_3
UITextSizeConstraint_4.MaxTextSize = 45

UIAspectRatioConstraint.Parent = gaming
UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height

midcirclebig.Name = "midcirclebig"
midcirclebig.Parent = gaming
midcirclebig.AnchorPoint = Vector2.new(0.5, 0.5)
midcirclebig.BackgroundColor3 = Color3.fromRGB(97, 0, 0)
midcirclebig.BackgroundTransparency = 1.000
midcirclebig.Position = UDim2.new(6.64598131, 120, 4.11706829, 0)
midcirclebig.Size = UDim2.new(3.31793284, 0, 3.25723886, 0)
midcirclebig.Image = "http://www.roblox.com/asset/?id=6900421398"
midcirclebig.ImageColor3 = Color3.fromRGB(255, 0, 105)

midcirclesmal.Name = "midcirclesmal"
midcirclesmal.Parent = gaming
midcirclesmal.AnchorPoint = Vector2.new(0.5, 0.5)
midcirclesmal.BackgroundColor3 = Color3.fromRGB(97, 0, 0)
midcirclesmal.BackgroundTransparency = 1.000
midcirclesmal.Position = UDim2.new(6.65609694, 120, 4.10695267, 0)
midcirclesmal.Size = UDim2.new(2.55925918, 0, 2.59972167, 0)
midcirclesmal.Image = "http://www.roblox.com/asset/?id=6900421398"
midcirclesmal.ImageColor3 = Color3.fromRGB(255, 0, 105)

-- Scripts:

local function MJJD_fake_script() -- PRIMARY.LocalScript 
	local script = Instance.new('LocalScript', PRIMARY)

	while wait() do
		script.Parent.BackgroundColor3 = game.Workspace.non.Head.Nametag.TextLabel.TextStrokeColor3;
	end
end
coroutine.wrap(MJJD_fake_script)()
local function CKIS_fake_script() -- square.LocalScript 
	local script = Instance.new('LocalScript', square)

	while wait() do
		script.Parent.Rotation = script.Parent.Rotation -4
	end
end
coroutine.wrap(CKIS_fake_script)()
local function UZQYPIJ_fake_script() -- square.LocalScript 
	local script = Instance.new('LocalScript', square)

	while wait() do
		script.Parent.BackgroundColor3 = PrimaryColor;
	end
end
coroutine.wrap(UZQYPIJ_fake_script)()
local function PHYES_fake_script() -- SECONDARY.LocalScript 
	local script = Instance.new('LocalScript', SECONDARY)

	while wait() do
		script.Parent.BackgroundColor3 = PrimaryColor;
	end
end
coroutine.wrap(PHYES_fake_script)()
local function DMEJ_fake_script() -- star.LocalScript 
	local script = Instance.new('LocalScript', star)

	while wait() do
		script.Parent.Rotation = script.Parent.Rotation +2
	end
end
coroutine.wrap(DMEJ_fake_script)()
local function XOABIHA_fake_script() -- star.LocalScript 
	local script = Instance.new('LocalScript', star)

	while wait() do
		script.Parent.ImageColor3 = PrimaryColor;
	end
end
coroutine.wrap(XOABIHA_fake_script)()
local function LSPDGFG_fake_script() -- smallcircle.LocalScript 
	local script = Instance.new('LocalScript', smallcircle)

	while wait() do
		script.Parent.Rotation = script.Parent.Rotation +1
	end
end
coroutine.wrap(LSPDGFG_fake_script)()
local function IRCJ_fake_script() -- smallcircle.LocalScript 
	local script = Instance.new('LocalScript', smallcircle)

	while wait() do
		script.Parent.ImageColor3 = game.Workspace.non.Head.Nametag.TextLabel.TextStrokeColor3;
	end
end
coroutine.wrap(IRCJ_fake_script)()
local function EDLXTF_fake_script() -- bigcircle.LocalScript 
	local script = Instance.new('LocalScript', bigcircle)

	while wait() do
		script.Parent.Rotation = script.Parent.Rotation +1
	end
end
coroutine.wrap(EDLXTF_fake_script)()
local function IQEWX_fake_script() -- bigcircle.LocalScript 
	local script = Instance.new('LocalScript', bigcircle)

	while wait() do
		script.Parent.ImageColor3 = game.Workspace.non.Head.Nametag.TextLabel.TextStrokeColor3;
	end
end
coroutine.wrap(IQEWX_fake_script)()
local function WYPDAZ_fake_script() -- bigcirc2.LocalScript 
	local script = Instance.new('LocalScript', bigcirc2)

	while wait() do
		script.Parent.Rotation = script.Parent.Rotation +1
	end
end
coroutine.wrap(WYPDAZ_fake_script)()
local function KWUQX_fake_script() -- bigcirc2.LocalScript 
	local script = Instance.new('LocalScript', bigcirc2)

	while wait() do
		script.Parent.ImageColor3 = PrimaryColor;
	end
end
coroutine.wrap(KWUQX_fake_script)()
local function OMCEPN_fake_script() -- GLOW2.LocalScript 
	local script = Instance.new('LocalScript', GLOW2)

	while wait() do
		script.Parent.Rotation = script.Parent.Rotation +4
	end
end
coroutine.wrap(OMCEPN_fake_script)()
local function LDSIQO_fake_script() -- GLOW2.LocalScript 
	local script = Instance.new('LocalScript', GLOW2)

	while wait() do
		script.Parent.ImageColor3 = PrimaryColor;
	end
end
coroutine.wrap(LDSIQO_fake_script)()
local function KJOZGJ_fake_script() -- smallcirc.LocalScript 
	local script = Instance.new('LocalScript', smallcirc)

	while wait() do
		script.Parent.Rotation = script.Parent.Rotation +4
	end
end
coroutine.wrap(KJOZGJ_fake_script)()
local function ACRBMT_fake_script() -- smallcirc.LocalScript 
	local script = Instance.new('LocalScript', smallcirc)

	while wait() do
		script.Parent.ImageColor3 = game.Workspace.non.Head.Nametag.TextLabel.TextStrokeColor3;
	end
end
coroutine.wrap(ACRBMT_fake_script)()
local function MNLDPHY_fake_script() -- SGNAME.LocalScript 
	local script = Instance.new('LocalScript', SGNAME)

	while wait() do
		script.Parent.TextColor3 = game.Workspace.non.Head.Nametag.TextLabel.TextStrokeColor3;
	end
end
coroutine.wrap(MNLDPHY_fake_script)()
local function HBTAIXS_fake_script() -- MODELABEL.LocalScript 
	local script = Instance.new('LocalScript', MODELABEL)

	while wait() do
		script.Parent.Font = Enum.Font:GetEnumItems()[math.random(1, #Enum.Font:GetEnumItems())]
		script.Parent.Rotation = math.random(-5, 5)
	end
end
coroutine.wrap(HBTAIXS_fake_script)()
local function QZMX_fake_script() -- MODELABEL.LocalScript 
	local script = Instance.new('LocalScript', MODELABEL)

	script.Disabled = true
	wait(2)
	script.Disabled = false
	
	while wait() do
		script.Parent.Text = game.Workspace.non.Head.Nametag.TextLabel.Text
	end
end
coroutine.wrap(QZMX_fake_script)()
local function ENLDXLI_fake_script() -- MODELABEL.LocalScript 
	local script = Instance.new('LocalScript', MODELABEL)

	while wait() do
		script.Parent.TextColor3 = game.Workspace.non.Head.Nametag.TextLabel.TextStrokeColor3;
	end
end
coroutine.wrap(ENLDXLI_fake_script)()
local function WWCCQ_fake_script() -- square2.LocalScript 
	local script = Instance.new('LocalScript', square2)

	while wait() do
		script.Parent.Rotation = script.Parent.Rotation +4
	end
end
coroutine.wrap(WWCCQ_fake_script)()
local function KILC_fake_script() -- square2.LocalScript 
	local script = Instance.new('LocalScript', square2)

	while wait() do
		script.Parent.BackgroundColor3 = game.Workspace.non.Head.Nametag.TextLabel.TextStrokeColor3;
	end
end
coroutine.wrap(KILC_fake_script)()
local function GHJTA_fake_script() -- SGNAME_2.LocalScript 
	local script = Instance.new('LocalScript', SGNAME_2)

	while wait() do
		script.Parent.TextColor3 = PrimaryColor;
	end
end
coroutine.wrap(GHJTA_fake_script)()
local function PEZZ_fake_script() -- SGNAME_3.LocalScript 
	local script = Instance.new('LocalScript', SGNAME_3)

	while wait() do
		script.Parent.TextColor3 = game.Workspace.non.Head.Nametag.TextLabel.TextStrokeColor3;
	end
end
coroutine.wrap(PEZZ_fake_script)()
local function OHJTTEW_fake_script() -- midcirclebig.LocalScript 
	local script = Instance.new('LocalScript', midcirclebig)

	while wait() do
		script.Parent.Rotation = script.Parent.Rotation +1
	end
end
coroutine.wrap(OHJTTEW_fake_script)()
local function GMJSE_fake_script() -- midcirclebig.LocalScript 
	local script = Instance.new('LocalScript', midcirclebig)

	while wait() do
		script.Parent.ImageColor3 = PrimaryColor;
	end
end
coroutine.wrap(GMJSE_fake_script)()
local function ZJIS_fake_script() -- midcirclesmal.LocalScript 
	local script = Instance.new('LocalScript', midcirclesmal)

	script.Disabled = true
	wait(1)
	script.Disabled = false
	
	while wait() do
		script.Parent.Rotation = script.Parent.Rotation -1
	end
end
coroutine.wrap(ZJIS_fake_script)()
local function PAMYI_fake_script() -- midcirclesmal.LocalScript 
	local script = Instance.new('LocalScript', midcirclesmal)

	while wait() do
		script.Parent.ImageColor3 = game.Workspace.non.Head.Nametag.TextLabel.TextStrokeColor3;
	end
end
coroutine.wrap(PAMYI_fake_script)()

-- Gui to Lua
-- Version: 3.2

-- Instances:

local ScreenGui = Instance.new("ScreenGui")
local SECONDARY = Instance.new("Frame")
local TextLabel = Instance.new("TextLabel")
local TextLabel_2 = Instance.new("TextLabel")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

SECONDARY.Name = "SECONDARY"
SECONDARY.Parent = ScreenGui
SECONDARY.AnchorPoint = Vector2.new(0.5, 0.5)
SECONDARY.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
SECONDARY.BackgroundTransparency = 0.600
SECONDARY.Position = UDim2.new(0.470512748, 0, 0.0470106751, 0)
SECONDARY.Size = UDim2.new(47.1793861, 0, 0.0942389965, 0)

TextLabel.Parent = ScreenGui
TextLabel.BackgroundColor3 = Color3.fromRGB(85, 170, 0)
TextLabel.BackgroundTransparency = 1.000
TextLabel.ClipsDescendants = true
TextLabel.Size = UDim2.new(1.01700008, 0, -0.0128216911, 100)
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = ""
TextLabel.TextScaled = true
TextLabel.TextSize = 14.000
TextLabel.TextWrapped = true

TextLabel_2.Parent = TextLabel
TextLabel_2.BackgroundColor3 = Color3.fromRGB(85, 170, 0)
TextLabel_2.BackgroundTransparency = 1.000
TextLabel_2.Position = UDim2.new(-0.0170000289, 0, -0.059375003, 0)
TextLabel_2.Size = UDim2.new(0.999608696, 0, 0.147622019, 0)
TextLabel_2.Font = Enum.Font.Antique
TextLabel_2.Text = "CORRODED GLITCHER"
TextLabel_2.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_2.TextSize = 75.000
TextLabel_2.TextWrapped = true

-- Scripts:

local function QSBO_fake_script() -- SECONDARY.LocalScript 
	local script = Instance.new('LocalScript', SECONDARY)

	while wait() do
		script.Parent.BackgroundColor3 = PrimaryColor;
	end
end
coroutine.wrap(QSBO_fake_script)()
local function MMYQH_fake_script() -- TextLabel_2.LocalScript 
	local script = Instance.new('LocalScript', TextLabel_2)

	while wait() do
		script.Parent.TextColor3 = game.Workspace.non.Head.Nametag.TextLabel.TextStrokeColor3;
	end
end
coroutine.wrap(MMYQH_fake_script)()
local function NKFW_fake_script() -- TextLabel.Script 
	local script = Instance.new('Script', TextLabel)

	local images = {script.Parent.TextLabel}
	
	while wait() do 
		for _,v in pairs(images) do
			local temp = v.Position.X.Scale
			if (temp <= -v.Size.X.Scale) then
				temp = 1.0
			end
			v.Position = UDim2.new(temp - 0.01, 0, 0.4, 0)
		end
	end
end
coroutine.wrap(NKFW_fake_script)()


	NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance)
		inst.Parent = parent
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end

	function newMotor(P0,P1,C0,C1)
		return NewInstance('Motor',P0,{Part0=P0,Part1=P1,C0=C0,C1=C1})
	end

	local welds = {}
	local WeldDefaults = {}

	table.insert(welds,newMotor(Torso,Head,CF.N(0,1.5,0),CF.N()))
	table.insert(welds,newMotor(Root,Torso,CF.N(),CF.N()))
	table.insert(welds,newMotor(Torso,RLeg,CF.N(.5,-1,0),CF.N(0,1,0)))
	table.insert(welds,newMotor(Torso,RArm,CF.N(1.5,.5,0),CF.N(0,.5,0)))
	table.insert(welds,newMotor(Torso,LLeg,CF.N(-.5,-1,0),CF.N(0,1,0)))
	table.insert(welds,newMotor(Torso,LArm,CF.N(-1.5,.5,0),CF.N(0,.5,0)))

	WeldDefaults={}
	for i = 1,#welds do
		local v=welds[i]
		WeldDefaults[i]=v.C0
	end

	local NK,RJ,RH,RS,LH,LS=unpack(welds)

	local NKC0,RJC0,RHC0,RSC0,LHC0,LSC0=unpack(WeldDefaults)

	function makeMusic(id,pit,timePos)
		local sound = Torso:FindFirstChild(Player.Name.."song") or Char:FindFirstChild(Player.Name.."song")
		local parent = (MusicMode==2 and Char or Torso)
		if(not sound)then 
			sound = NewInstance("Sound",parent,{Name=Player.Name.."song",Volume=(MusicMode==3 and 0 or 5),Pitch=(pit or 1),Looped=true})
			NewInstance("EqualizerSoundEffect",sound,{HighGain=0,MidGain=2,LowGain=10})
		end
		if(id=='stop')then
			if(sound)then
				sound:Stop()
			end
		else
			local timePos = typeof(timePos)=='number' and timePos or sound.TimePosition
			sound.Volume = (MusicMode==3 and 0 or 5)
			sound.Name = Player.Name.."song"
			sound.Looped=true
			sound.SoundId = "rbxassetid://"..id
			sound.Pitch=(pit or 1)
			sound:Play()
			sound.TimePosition = timePos
		end
		return sound;
	end

	function playMusic(id,pitch,timePos)
		return makeMusic(id,pitch,timePos)
	end

	for _,v in next, Hum:GetPlayingAnimationTracks() do
		v:Stop(0);
	end

	-- SCRIPT STUFF --

	function swait(num)
		if num == 0 or num == nil then
			game:GetService("RunService").RenderStepped:wait()
		else
			for i = 0, num do
				game:GetService("RunService").RenderStepped:wait()
			end
		end
	end

	--// Effects \\--

	function Tween(obj,props,time,easing,direction,repeats,backwards)
		local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
		local tween = S.TweenService:Create(obj, info, props)

		tween:Play()
	end

	function StartShake(Settings)
		return true
	end

	function Camshake(shakedata)
		StartShake(shakedata)
	end

	local Effects=NewInstance("Folder",Char)
	Effects.Name=Player.Name..'Effects'


	function ShowDamage(Pos, Text, Time, Color)
		local Pos = Pos or V3.N(0, 0, 0)
		local Text = tostring(Text or "")
		local Time = Time or 2
		local Color = Color or C3.N(1, 0, 1)
		local EffectPart = Part(Effects,Color,Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),CFrame.new(Pos),true,false)
		EffectPart.Transparency=1
		local BillboardGui = NewInstance("BillboardGui",EffectPart,{
			Size = UDim2.new(3,0,3,0),
			Adornee = EffectPart,
		})

		local TextLabel = NewInstance("TextLabel",BillboardGui,{
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			TextColor3 = Color,
			TextScaled = true,
			Font = Enum.Font.ArialBold, 
		})
		S.Debris:AddItem(EffectPart, Time+.5)
		delay(0, function()
			local rot=math.random(-10,10)/15
			local raise=.2
			local Frames = Time/Frame_Speed
			for i=0,1.1,.02 do
				swait()
				TextLabel.Rotation=TextLabel.Rotation+rot
				raise=raise-.008
				EffectPart.Position = EffectPart.Position + Vector3.new(0, raise, 0)
				TextLabel.TextTransparency=i
				TextLabel.TextStrokeTransparency=i
			end
			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end)
	end


	local baseSound = IN("Sound")

	function Soond(parent,id,pitch,volume,looped,effect,autoPlay)
		local Sound = baseSound:Clone()
		Sound.SoundId = "rbxassetid://".. tostring(id or 0)
		Sound.Pitch = pitch or 1
		Sound.Volume = volume or 1
		Sound.Looped = looped or false
		if(autoPlay)then
			coroutine.wrap(function()
				repeat wait() until Sound.IsLoaded
				Sound.Playing = autoPlay or false
			end)()
		end
		if(not looped and effect)then
			Sound.Stopped:connect(function()
				Sound.Volume = 0
				Sound:destroy()
			end)
		elseif(effect)then
			warn("Sound can't be looped and a sound effect!")
		end
		Sound.Parent =parent or Torso
		return Sound
	end

	function SoondPart(id,pitch,volume,looped,effect,autoPlay,cf)
		local soundPart = NewInstance("Part",Effects,{Transparency=1,CFrame=cf or Torso.CFrame,Anchored=true,CanCollide=false,Size=V3.N()})
		local Sound = IN("Sound")
		Sound.SoundId = "rbxassetid://".. tostring(id or 0)
		Sound.Pitch = pitch or 1
		Sound.Volume = volume or 1
		Sound.Looped = looped or false
		if(autoPlay)then
			coroutine.wrap(function()
				repeat wait() until Sound.IsLoaded
				Sound.Playing = autoPlay or false
			end)()
		end
		if(not looped and effect)then
			Sound.Stopped:connect(function()
				Sound.Volume = 0
				soundPart:destroy()
			end)
		elseif(effect)then
			warn("Sound can't be looped and a sound effect!")
		end
		Sound.Parent = soundPart
		return Sound,soundPart
	end

	function SoundPart(...)
		return SoondPart(...)
	end

	function Sound(...)
		return Soond(...)
	end

	function Part(parent,color,material,size,cframe,anchored,cancollide)
		local part = IN("Part")
		part.Parent = parent or Char
		part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
		part.Material = material or Enum.Material.SmoothPlastic
		part.TopSurface,part.BottomSurface=10,10
		part.Size = size or V3.N(1,1,1)
		part.CFrame = cframe or CF.N(0,0,0)
		part.CanCollide = cancollide or false
		part.Anchored = anchored or false
		return part
	end

	function Weld(part0,part1,c0,c1)
		local weld = IN("Weld")
		weld.Parent = part0
		weld.Part0 = part0
		weld.Part1 = part1
		weld.C0 = c0 or CF.N()
		weld.C1 = c1 or CF.N()
		return weld
	end

	function Mesh(parent,meshtype,meshid,textid,scale,offset)
		local part = IN("SpecialMesh")
		part.MeshId = meshid or ""
		part.TextureId = textid or ""
		part.Scale = scale or V3.N(1,1,1)
		part.Offset = offset or V3.N(0,0,0)
		part.MeshType = meshtype or Enum.MeshType.Sphere
		part.Parent = parent
		return part
	end

	function GotEffect(data)
		-- just for easy reference
		local color = data.Color or Color3.new(.7,.7,.7);
		local endcolor = data.EndColor or nil;
		local mat = data.Material or Enum.Material.SmoothPlastic;
		local cframe = data.CFrame or CFrame.new();
		local endpos = data.EndPos or nil;
		local meshdata = data.Mesh or {}
		local sounddata = data.Sound or {}
		local size = data.Size or Vector3.new(1,1,1)
		local endsize = data.EndSize or Vector3.new(6,6,6)
		local rotinc = data.RotInc or {0,0,0} -- ONLY FOR LEGACY SYSTEM
		local transparency = data.Transparency or NumberRange.new(0,1)
		local acceleration = data.Acceleration or nil; -- ONLY FOR LEGACY SYSTEM
		local endrot = data.EndRotation or {0,0,0} -- ONLY FOR EXPERIMENTAL SYSTEM
		local style = data.Style or false; -- ONLY FOR EXPERIMENTAL SYSTEM
		local lifetime = data.Lifetime or 1;
		local system = data.FXSystem;
		local setpart = typeof(data.Part)=='string' and EffectFolder:FindFirstChild(tostring(data.Part)):Clone() or typeof(data.Part)=='Instance' and data.Part or nil

		local S,PM;

		local P = setpart or Part(Effects,color,mat,Vector3.new(1,1,1),cframe,true,false)

		if(not P:IsA'MeshPart' and not P:IsA'UnionOperation')then
			if(meshdata == "Blast")then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://20329976','',size,Vector3.new(0,0,-size.X/8))
			elseif(meshdata == 'Ring')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://559831844','',size,Vector3.new(0,0,0))
			elseif(meshdata == 'Slash1')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://662586858','',Vector3.new(size.X/10,.001,size.Z/10),Vector3.new(0,0,0))
			elseif(meshdata == 'Slash2')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://448386996','',Vector3.new(size.X/1000,size.Y/100,size.Z/100),Vector3.new(0,0,0))
			elseif(meshdata == 'Tornado1')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://443529437','',size/10,Vector3.new(0,0,0))
			elseif(meshdata == 'Tornado2')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://168892432','',size/4,Vector3.new(0,0,0))
			elseif(meshdata == 'Skull')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://4770583','',size*2,Vector3.new(0,0,0))
			elseif(meshdata == 'Crystal')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://9756362','',size,Vector3.new(0,0,0))
			elseif(meshdata == 'Cloud')then
				PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://1095708','',size,Vector3.new(0,0,0))
			elseif(typeof(meshdata) == 'table')then
				local Type = meshdata.Type or Enum.MeshType.Brick
				local ID = meshdata.ID or '';
				local Tex = meshdata.Texture or '';
				local Offset = meshdata.Offset or Vector3.new(0,0,0)
				PM = Mesh(P,Type,ID,Tex,size,Offset)
			else
				PM = Mesh(P,Enum.MeshType.Brick,'','',size)
			end
		end
		local startTrans = typeof(transparency) == 'number' and transparency or typeof(transparency) == 'NumberRange' and transparency.Min or typeof(transparency) == 'table' and transparency[1] or 0
		local endTrans = typeof(transparency) == 'NumberRange' and transparency.Max or typeof(transparency) == 'table' and transparency[2] or 1

		P.Material = mat
		P.CFrame = cframe
		P.Color = (typeof(color)=='BrickColor' and color.Color or color)
		P.Anchored = true
		P.CanCollide = false
		P.Transparency = startTrans
		P.Parent = Effects
		local random = Random.new();
		game:service'Debris':AddItem(P,lifetime+3)


		-- actual effect stuff
		local mult = 1;
		if(PM)then
			if(PM.MeshId == 'rbxassetid://20329976')then
				PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
			elseif(PM.MeshId == 'rbxassetid://4770583')then
				mult = 2
			elseif(PM.MeshId == 'rbxassetid://168892432')then
				mult = .25
			elseif(PM.MeshId == 'rbxassetid://443529437')then
				mult = .1
			elseif(PM.MeshId == 'rbxassetid://443529437')then
				mult = .1
			end
		end	
		coroutine.wrap(function()
			if(system == 'Legacy' or system == 1 or system == nil)then
				local frames = (typeof(lifetime) == 'NumberRange' and random:NextNumber(lifetime.Min,lifetime.Max) or typeof(lifetime) == 'number' and lifetime or 1)*Frame_Speed
				for i = 0, frames do
					local div = (i/frames)
					P.Transparency=(startTrans+(endTrans-startTrans)*div)

					if(PM)then PM.Scale = size:lerp(endsize*mult,div) else P.Size = size:lerp(endsize*mult,div) end

					local RotCF=CFrame.Angles(0,0,0)

					if(rotinc == 'random')then
						RotCF=CFrame.Angles(math.rad(random:NextNumber(-180,180)),math.rad(random:NextNumber(-180,180)),math.rad(random:NextNumber(-180,180)))
					elseif(typeof(rotinc) == 'table')then
						RotCF=CFrame.Angles(unpack(rotinc))
					end

					if(PM and PM.MeshId == 'rbxassetid://20329976')then
						PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
					end

					if(endpos and typeof(endpos) == 'CFrame')then
						P.CFrame=cframe:lerp(endpos,div)*RotCF
					elseif(acceleration and typeof(acceleration) == 'table' and acceleration.Force)then
						local force = acceleration.Force;
						if(typeof(force)=='CFrame')then
							force=force.p;
						end
						if(typeof(force)=='Vector3')then
							if(acceleration.LookAt)then
								P.CFrame=(CFrame.new(P.Position,force)+force)*RotCF
							else
								P.CFrame=(P.CFrame+force)*RotCF
							end
						end
					else
						P.CFrame=P.CFrame*RotCF
					end

					if(endcolor and typeof(endcolor) == 'Color3')then
						P.Color = color:lerp(endcolor,div)
					end
					swait()
				end
				P:destroy()
			elseif(system == 'Experimental' or system == 2)then
				local info = TweenInfo.new(lifetime,style,Enum.EasingDirection.InOut,0,false,0)
				local info2 = TweenInfo.new(lifetime,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut,0,false,0)
				if(style == Enum.EasingStyle.Elastic)then
					info = TweenInfo.new(lifetime*2,style,Enum.EasingDirection.Out,0,false,0)
				elseif(style == Enum.EasingStyle.Bounce)then
					info = TweenInfo.new(lifetime,style,Enum.EasingDirection.Out,0,false,0)
				end
				local tweenPart = game:service'TweenService':Create(P,info2,{
					CFrame=(typeof(endpos) == 'CFrame' and endpos or P.CFrame)*CFrame.Angles(unpack(endrot)),
					Color=typeof(endcolor) == 'Color3' and endcolor or color,
					Transparency=endTrans,
				})
				local off = Vector3.new(0,0,0)
				if(PM.MeshId == 'rbxassetid://20329976')then off=Vector3.new(0,0,(endsize*mult).Z/8) end

				local tweenMesh = game:service'TweenService':Create(PM,info,{
					Scale=endsize*mult,
					Offset=off,
				})
				tweenPart:Play()
				tweenMesh:Play()
			end
		end)()
	end

	function Effect(edata)
		GotEffect(edata)
	end

	function Trail(data)
		coroutine.wrap(function()
			data.Frames = typeof(data.Frames)=='number' and data.Frames or 60
			data.CFrame = typeof(data.CFrame)=='CFrame' and data.CFrame or Root.CFrame
			local ep = typeof(data.EndPos)=='CFrame' and data.EndPos or data.CFrame*CFrame.new(0,5,0);
			data.EndPos=nil
			local trailPart = Part(Effects,BrickColor.new'White',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),data.CFrame,true,false)
			trailPart.Transparency=1
			local start = data.CFrame
			for i = 1, data.Frames do
				trailPart.CFrame = start:lerp(ep,i/data.Frames)
				data.CFrame = trailPart.CFrame
				Effect(data)
				swait()
			end	
		end)()
	end

	function ClientTrail(data)
		coroutine.wrap(function()
			data.Frames = typeof(data.Frames)=='number' and data.Frames or 60
			data.CFrame = typeof(data.CFrame)=='CFrame' and data.CFrame or Root.CFrame
			local ep = typeof(data.EndPos)=='CFrame' and data.EndPos or data.CFrame*CFrame.new(0,5,0);
			data.EndPos=nil
			local trailPart = Part(Effects,BrickColor.new'White',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),data.CFrame,true,false)
			trailPart.Transparency=1
			local start = data.CFrame
			for i = 1, data.Frames do
				trailPart.CFrame = start:lerp(ep,i/data.Frames)
				data.CFrame = trailPart.CFrame
				GotEffect(data)
				swait()
			end	
		end)()
	end


	if(Char:FindFirstChild('NGRWings'..Player.Name))then
		Char['NGRWings'..Player.Name]:destroy()
	end

	for _,v in next, Char:children() do
		if(v.Name:lower():find'wings')then 
			v:destroy()
		end
	end

	local wingModel = Instance.new("Model",Char)
	wingModel.Name="NGRWings"..Player.Name
	local rightWing = NewInstance("Model",wingModel,{Name='Right'})
	local leftWing = NewInstance("Model",wingModel,{Name='Left'})

	local MPASword = {}
	for _,v in pairs(Char:GetChildren()) do
		if v:IsA("Accessory") and v.Name:find("MeshPartAccessory") and v.Handle.Size == Vector3.new(4,4,1) then
			table.insert(MPASword,v)
		end
	end

	
local LWP1 = WingPiece:Clone();
if Char:FindFirstChild("swordlol") then
	for _,v in pairs(LWP1:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 0
		end
	end
	local athp = Instance.new("Attachment",LWP1.PrimaryPart)
	local atho = Instance.new("Attachment",LWP1.PrimaryPart)

	local HatChoice = Char:FindFirstChild("swordlol")
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho

athp.Position = Vector3.new(0,-3,0)
	atho.Rotation = Vector3.new(-90,140,90)
	table.remove(MPASword,1)
end
LWP1.Parent = leftWing
local LWP2 = WingPiece:Clone();
if Char:FindFirstChild("uhyes") then
	for _,v in pairs(LWP2:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 0
		end
	end
	local athp = Instance.new("Attachment",LWP2.PrimaryPart)
	local atho = Instance.new("Attachment",LWP2.PrimaryPart)

	local HatChoice = Char:FindFirstChild("uhyes")
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho

	athp.Position = Vector3.new(0,-3,0)
	atho.Rotation = Vector3.new(-90,140,90)
	table.remove(MPASword,1)
end
LWP2.Parent = leftWing
local LWP3 = WingPiece:Clone();
if Char:FindFirstChild("DemonLordSword") then
	for _,v in pairs(LWP3:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 0
		end
	end
	local athp = Instance.new("Attachment",LWP3.PrimaryPart)
	local atho = Instance.new("Attachment",LWP3.PrimaryPart)

	local HatChoice = Char:FindFirstChild("DemonLordSword")
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho

athp.Position = Vector3.new(0,-3,0)
	atho.Rotation = Vector3.new(-90,140,90)
end
LWP3.Parent = leftWing
local RWP1 = WingPiece:Clone();
if Char:FindFirstChild("aesword") then
	for _,v in pairs(RWP1:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 0
		end
	end
	local athp = Instance.new("Attachment",RWP1.PrimaryPart)
	local atho = Instance.new("Attachment",RWP1.PrimaryPart)

	local HatChoice = Char:FindFirstChild("aesword")
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho

athp.Position = Vector3.new(0,-3,0)
	atho.Rotation = Vector3.new(-90,140,90)
	table.remove(MPASword,1)
end
RWP1.Parent = rightWing
local RWP2 = WingPiece:Clone();
if Char:FindFirstChild("poggers") then
	for _,v in pairs(RWP2:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 0
		end
	end
	local athp = Instance.new("Attachment",RWP2.PrimaryPart)
	local atho = Instance.new("Attachment",RWP2.PrimaryPart)

	local HatChoice = Char:FindFirstChild("poggers")
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho

athp.Position = Vector3.new(0,-3,0)
	atho.Rotation = Vector3.new(-90,140,90)
	table.remove(MPASword,1)
end
RWP2.Parent = rightWing
local RWP3 = WingPiece:Clone();
if Char:FindFirstChild("CorruptLordSword") then
	for _,v in pairs(RWP3:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 0
		end
	end
	local athp = Instance.new("Attachment",RWP3.PrimaryPart)
	local atho = Instance.new("Attachment",RWP3.PrimaryPart)

	local HatChoice = Char:FindFirstChild("CorruptLordSword")
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho

	athp.Position = Vector3.new(0,-3,0)
	atho.Rotation = Vector3.new(-90,140,90)
end

RWP3.Parent = rightWing
local RWP4 = WingPiece:Clone();
if Char:FindFirstChild("swordhalo") then
	for _,v in pairs(RWP4:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 0
		end
	end
	local athp = Instance.new("Attachment",RWP4.PrimaryPart)
	local atho = Instance.new("Attachment",RWP4.PrimaryPart)

	local HatChoice = Char:FindFirstChild("swordhalo")
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho

	athp.Position = Vector3.new(0.000354767, 0.502605, -0.0858269)
	atho.Rotation = Vector3.new(0,0,0)
end

RWP4.Parent = rightWing
local RWP5 = WingPiece:Clone();
if Char:FindFirstChild("Auragamer") then
	for _,v in pairs(RWP5:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 0
		end
	end
	local athp = Instance.new("Attachment",RWP5.PrimaryPart)
	local atho = Instance.new("Attachment",RWP5.PrimaryPart)

	local HatChoice = Char:FindFirstChild("Auragamer")
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho

	athp.Position = Vector3.new(0,0,0)
	atho.Rotation = Vector3.new(0,0,0)
end




	RWP5.Parent = rightWing
	local LWP1W=Weld(LWP1.PrimaryPart,Torso,CF.N(2,-2,-1)*CF.A(0,0,0))
	local LWP2W=Weld(LWP2.PrimaryPart,Torso,CF.N(4.25,-1,-1)*CF.A(0,0,M.R(15)))
	local LWP3W=Weld(LWP3.PrimaryPart,Torso,CF.N(6.5,.5,-1)*CF.A(0,0,M.R(30)))

	local RWP1W=Weld(RWP1.PrimaryPart,Torso,CF.N(-2,-2,-1)*CF.A(0,0,0))
	local RWP2W=Weld(RWP2.PrimaryPart,Torso,CF.N(-4.25,-1,-1)*CF.A(0,0,M.R(-15)))
	local RWP3W=Weld(RWP3.PrimaryPart,Torso,CF.N(-6.5,.5,-1)*CF.A(0,0,M.R(-30)))
	local RWP4W=Weld(RWP4.PrimaryPart,Torso,CF.N(-6.5,.5,-1)*CF.A(0,0,M.R(-30)))
	local RWP5W=Weld(RWP5.PrimaryPart,Torso,CF.N(-6.5,.5,-1)*CF.A(0,0,M.R(-30)))

	local bbg=Head:FindFirstChild'Nametag' or NewInstance("BillboardGui",Head,{
		Adornee=Head;
		Name='Nametag';
		Size=UDim2.new(4,0,1.2,0);
		StudsOffset=V3.N(-8,5.3,0);
	})
	local text=bbg:FindFirstChild'TextLabel' or NewInstance("TextLabel",bbg,{
		Size=UDim2.new(5,0,3.5,0);
		TextScaled=true;
		BackgroundTransparency=1;
		TextStrokeTransparency=0;
		Font=Enum.Font.PermanentMarker;
		TextColor3=C3.N(1,1,1);
		Text=startmode
	})

	function getMode(modeName)
		for i,v in next, modeInfo do
			if(v.Name==modeName)then
				return v
			end
		end
		return modeInfo[1]
	end

	function IsVaporwave(song)
		for i = 1,#VaporwaveSongs do
			if(VaporwaveSongs[i]==song)then
				return true
			end
		end
		return false
	end

	local blush = NewInstance('Decal',Head,{Transparency=1,Texture='rbxassetid://0',Color3=(Player.UserId==5719877 and C3.N(.45,0,1) or C3.N(1,0,0))})

	function changeMudo(modeName)
		local info = getMode(modeName)
		Mode=info.Name
		WalkSpeed=info.Walkspeed
		movement=info.moveVal
		music=makeMusic(info.Music or 0,info.Pitch or 1,info.TimePos or music and music.TimePosition or 0)
		WingAnim=info.WingAnim or 'meowldarkXD1'
		text.Text = info.Name
		text.TextColor3 = info.LeftWing[2]
		text.TextStrokeColor3 = info.StrokeColor
		text.Font=info.Font;
		if(Mode=='Love' or Mode=='Lust')then
			blush.Transparency=0
			blush.Texture='rbxassetid://2664127437'
		else
			blush.Transparency=1
			blush.Texture='rbxassetid://0'
		end
		for _,v in next,leftWing:GetDescendants() do
			if(v:IsA'BasePart' and v.Name~='Main')then
				--v.Transparency=info.LeftWing[1]
				v.Color=info.LeftWing[2]
				v.Material=info.LeftWing[3]
			elseif(v:IsA'Trail')then
				--v.Transparency=NumberSequence.new(info.LeftWing[1],1)
				v.Color=ColorSequence.new(info.LeftWing[2])	
			end
		end

		for _,v in next,rightWing:GetDescendants() do
			if(v:IsA'BasePart' and v.Name~='Main')then
				--v.Transparency=info.RightWing[1]
				v.Color=info.RightWing[2]
				v.Material=info.RightWing[3]
			elseif(v:IsA'Trail')then
				--v.Transparency=NumberSequence.new(info.RightWing[1],1)
				v.Color=ColorSequence.new(info.RightWing[2])	
			end
		end

		PrimaryColor = info.PrimaryColor or info.LeftWing[2]
		SecondaryColor = info.SecondaryColor or info.RightWing[2]
	end



	function changeMode(modeName)
		changeMudo(modeName)
	end	

	function syncStuff(data)
		local neut,legwelds,c0s,c1s,sine,mov,walk,inc,musicmode,tpos,pit,wingsin,visSett,mode,newhue=unpack(data)
		local head0,torso0,rleg0,rarm0,lleg0,larm0=unpack(c0s)
		local head1,torso1,rleg1,rarm1,lleg1,larm1=unpack(c1s)
		legAnims=legwelds
		NeutralAnims=neut
		if(not neut)then
			NK.C0=head0
			RJ.C0=torso0
			RH.C0=rleg0
			RS.C0=rarm0
			LH.C0=lleg0
			LS.C0=larm0

			NK.C1=head1
			RJ.C1=torso1
			RH.C1=rleg1
			RS.C1=rarm1
			LH.C1=lleg1
			LS.C1=larm1
		end
		if(Mode~=mode)then
			changeMudo(mode)
		end
		movement=mov
		walking=walk
		Change=inc
		print(MusicMode,musicmode)
		if(musicmode~=MusicMode and music)then
			MusicMode=musicmode
			if(MusicMode==1)then
				music:Pause()
				music.Volume=5
				music.Parent=Torso
				music:Resume()
			elseif(MusicMode==2)then
				music:Pause()
				music.Volume=5
				music.Parent=Char
				music:Resume()
			elseif(MusicMode==3)then
				music.Volume = 0
			end
		end
		if(Sine-sine>.8 or Sine-sine<-.8)then
			Sine=sine
		end
		if(hue-newhue>.8 or hue-newhue<-.8)then
			hue=newhue
		end
		if(WingSine-wingsin>.8 or WingSine-wingsin<-.8)then
			WingSine=wingsin
		end
		if(music and (music.TimePosition-tpos>.8 or music.TimePosition-tpos<-.8))then
			music.TimePosition=tpos
		end
		if(music and pit)then
			music.Pitch = pit
		end
		if(Mode=='Troubadour' and music.SoundId~='rbxassetid://'..visSett.Music)then
			music.SoundId='rbxassetid://'..visSett.Music
		end
		getMode('Troubadour').Music = visSett.Music
		getMode('Troubadour').Pitch = visSett.Pitch
	end


	local footstepSounds = {
		[Enum.Material.Grass]=510933218;
		[Enum.Material.Metal]=1263161138;
		[Enum.Material.CorrodedMetal]=1263161138;
		[Enum.Material.DiamondPlate]=1263161138;
		[Enum.Material.Wood]=2452053757;
		[Enum.Material.WoodPlanks]=2452053757;
		[Enum.Material.Sand]=134456884;
		[Enum.Material.Snow]=2452051182;
	}


	function Vaporwaveify(s)
		local function wide(a)
			if a<'!' or a>'~' then return a end
			if a==' ' then return '  ' end 
			a = a:byte()+160
			if a<256 then return string.char(239,188,a-64) end
			return string.char(239,189,a-128)
		end
		return(s:gsub(".",wide))
	end



	function Choot(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=Enum.Font.Antique,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
	end
	
		function Choot2(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=game.Workspace.non.Head.Nametag.TextLabel.Font,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
		end
		
		
				function Choot8(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=game.Workspace.non.Head.Nametag.TextLabel.Font,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
		end
		
		function Choot3(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=game.Workspace.non.Head.Nametag.TextLabel.Font,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
		end
		function Choot4(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=game.Workspace.non.Head.Nametag.TextLabel.Font,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
	end

		function Choot5(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=game.Workspace.non.Head.Nametag.TextLabel.Font,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
		end
		function Choot6(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=game.Workspace.non.Head.Nametag.TextLabel.Font,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
		end
		function Choot7(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=game.Workspace.non.Head.Nametag.TextLabel.Font,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
		end

		function Choot8(text)
		--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,15,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=game.Workspace.non.Head.Nametag.TextLabel.Font,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
		--else
		--	Chat2(text)
		--end
	end

	function Chat(text)
		Choot(text)
	end
	
	function Chat8(text)
		Choot8(text)
	end
	
	function Chat7(text)
		Choot7(text)
	end
	
		function Chat8(text)
		Choot8(text)
	end
	
    function Chat2(text)
		Choot2(text)
    end
    
    function Chat3(text)
		Choot3(text)
    end
    
    function Chat4(text)
		Choot4(text)
    end

    function Chat5(text)
		Choot5(text)
    end
    
    function Chat6(text)
		Choot6(text)
	end

	function DealDamage(...)
		return true
	end

	function getRegion(point,range,ignore)
		return workspace:FindPartsInRegion3WithIgnoreList(R3.N(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
	end
	function AOEDamage(where,range,options)
		local hit = {}
		for _,v in next, getRegion(where,range,{Char}) do
			if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' and not hit[v.Parent:FindFirstChildOfClass'Humanoid'])then
				local callTable = {Who=v.Parent}
				hit[v.Parent:FindFirstChildOfClass'Humanoid'] = true
				for _,v in next, options do callTable[_] = v end
				DealDamage(callTable)
			end
		end
		return hit
	end


	function Click1()
		Attack=true
		NeutralAnims=false
		legAnims=false
		local orig = WalkSpeed
		WalkSpeed=0
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
			RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
			LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-1.3,0.5,-0.5)*CF.A(M.R(90),M.R(0),M.R(19.1)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(1.3,0.5,-0.5)*CF.A(M.R(90),M.R(0),M.R(-21.3)),Alpha)
			NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		end
		coroutine.wrap(function()
			for i = 1, 1 do
				Camshake({
					Duration=.2;
					FadeOut=.2;
					Intensity=1.5;
					Position=Vector3.new(.5,.5,.5);
					Rotation=Vector3.new(.5,.5,3);
					DropDist=15;
					IneffectiveDist=40;
					Origin=Root.CFrame*CF.N(0,0,-4-i*4);
				})
				SoundPart(206083252,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
				AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
					DamageColor=PrimaryColor;
					MinimumDamage=25;
					MaximumDamage=45;
				})
								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Color=PrimaryColor;
					Transparency={0.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(100,100,100);
					}
					
													Effect{
				Lifetime=2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Color=PrimaryColor;
					Transparency={0.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(100,100,100);
					}
					
					
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
													    GotEffect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,130,0.2);
				}
			

				
				swait(4)
			end
		end)()
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
			RJ.C0 = RJ.C0:lerp(CF.N(0,-0.2,0.7)*CF.A(M.R(18.2),M.R(0),M.R(0)),Alpha)
			LH.C0 = LH.C0:lerp(CF.N(-0.5,-1.1,-0.4)*CF.A(M.R(-33.4),M.R(0),M.R(0)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(0.5,-0.9,-0.2)*CF.A(M.R(-6.7),M.R(0),M.R(0)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-1.4,0.4,0.1)*CF.A(M.R(90.7),M.R(-2.5),M.R(-50)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,0.2)*CF.A(M.R(89.5),M.R(2.6),M.R(50)),Alpha)
			NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		end
		WalkSpeed=orig
		legAnims=true
		Attack=false
		NeutralAnims=true
	end

	function SwordSummon()
		Attack = true
		NeutralAnims = false
		local orig=WalkSpeed
		WalkSpeed=4
		legAnims=false
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
			Effect{
				Lifetime=.25;
				Mesh={Type=Enum.MeshType.Sphere};
				CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
				Color=PrimaryColor;
				Transparency={.5,1};
				Material=Enum.Material.Neon;
				Size=Vector3.new(.6,1,.6);
				EndSize=Vector3.new(.1,3,.1);
			}
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-230-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(230+0*M.C(Sine/32))),Alpha)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.95,0.,M.R(-5.5)),Alpha)
					RH.C0 = RH.C0:lerp(LHC0*CF.N(1,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.95,0.,M.R(-5.5)),Alpha)
		end
		for i = 0, 10 do
			delay(.05*i,function()
				local pos = Root.CFrame*CF.N(0,-2,-2-i*4)*CF.A(M.R(80),0,0)
				local pos2 = Root.CFrame*CF.N(0,-3,-2-i*4)
				Camshake({
					Duration=.2;
					FadeOut=.2;
					Intensity=1.5;
					Position=Vector3.new(.5,.5,.5);
					Rotation=Vector3.new(.5,.5,3);
					DropDist=15;
					IneffectiveDist=40;
					Origin=pos2;
				})
				AOEDamage(pos.p,5,{
					DamageColor=(Mode=='Troubadour' and C3.HSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor);
					MinimumDamage=(Mode=='Troubadour' and music.PlaybackLoudness/10 or 10);
					MaximumDamage=(Mode=='Troubadour' and music.PlaybackLoudness/8 or 35);
				})
				SoundPart(178452221,1,2,false,true,true,pos)
				for i = 1, 2 do
				    																							Effect{
				Lifetime=0.4;
					--Mesh={Type=Enum.MeshType.Sphere};
					Part = 'Sword',
					Color=PrimaryColor;
					CFrame = Root.CFrame* CF.N(math.random(-20,20),-3,math.random(-20,20)) * CF.A(1.5,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=V3.N(0.8,2.5,6.8);
					EndSize=V3.N(0.8,2.5,16);
					}
				end
			end)
		end
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(-45+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.2+.25*M.C(Sine/0.5),0)*CF.A(M.R(-45+1*M.S(Sine/64)),M.R(0),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
		end
		legAnims=true
		WalkSpeed=orig
		Attack = false
		NeutralAnims = true
	end

	function Bombs()
		Attack=true
		NeutralAnims=false
		legAnims=false
		local orig = WalkSpeed
		WalkSpeed=0
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-230-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(230+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
		end
		coroutine.wrap(function()
			for i = 1, 1 do
				Camshake({
					Duration=.2;
					FadeOut=.2;
					Intensity=1.5;
					Position=Vector3.new(.5,.5,.5);
					Rotation=Vector3.new(.5,.5,3);
					DropDist=15;
					IneffectiveDist=40;
					Origin=Root.CFrame*CF.N(0,0,-4-i*4);
				})
				SoundPart(206083252,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
				AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
					DamageColor=PrimaryColor;
					MinimumDamage=25;
					MaximumDamage=45;
				})
				
																					    GotEffect{
					Lifetime=0.6;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
                    Color=PrimaryColor;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(200,200,200);
				}
														Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1000,1);
					EndSize=Vector3.new(30,1000,30);
					}
																			Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(60,10,60);
					}
					
																								Effect{
				Lifetime=2;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(90,10,90);
					}
			
				swait(4)
			end
		end)()
		for i = 0, 1, 0.1 do
			swait()
			local Alpha = .3
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-140-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(140+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
		end
		WalkSpeed=orig
		legAnims=true
		Attack=false
		NeutralAnims=true
	end


	function ClickCombo()
		ClickTimer=180
		if(Combo==1)then
			Click1()
			Combo=2
		elseif(Combo==2)then
			SwordSummon()
			Combo=3
		elseif(Combo==3)then
			Bombs()
			Combo=1
		end
	end
	
	function destrucattack()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"DESTRUCTION IS EVERYTHING!"
	for i = 0, 7, 0.1 do
		swait()
		local Alpha = .1
          RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0.6)*CF.A(1.7,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(50+5*M.C(Sine/32))),Alpha)
              									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.7,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.6)*CF.A(-0.5,M.R(-5),0),Alpha)
	end
	
		
		coroutine.wrap(function()
		for i = 0, 1 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})

								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
					
					wait(0.5)
													Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(700,700,700);
					}
								Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,50,400);
					}
		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
  					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.4+.05*M.C(Sine/32),0)*CF.A(M.R(-20+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0.5)*CF.A(0.5,M.R(5+5*M.C(Sine/32)),M.R(10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(150-5*M.C(Sine/32)),M.R(75+2*M.C(Sine/1))),Alpha)
          					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-65),-0.2,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.4-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(7),0),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function PNEU()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"Let the desease spread!!"
	for i = 0, 7, 0.1 do
		swait()
		local Alpha = .1
          RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0.6)*CF.A(1.7,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(50+5*M.C(Sine/32))),Alpha)
              									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.7,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.6)*CF.A(-0.5,M.R(-5),0),Alpha)
	end
	
		
		coroutine.wrap(function()
		for i = 0, 1 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})

								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
					
					wait(0.5)
													Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(700,700,700);
					}
								Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,50,400);
					}
		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
  					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.4+.05*M.C(Sine/32),0)*CF.A(M.R(-20+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0.5)*CF.A(0.5,M.R(5+5*M.C(Sine/32)),M.R(10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(150-5*M.C(Sine/32)),M.R(75+2*M.C(Sine/1))),Alpha)
          					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-65),-0.2,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.4-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(7),0),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function calamattack()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"WELCOME TO THE BEGINNING OF THE END"
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[CALAMITY]: WELCOME TO THE BEGINNING OF THE END!", "All")
	

	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-230-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(230+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
	end
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})



								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
								Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,50,400);
					}
		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-140-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(140+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end


function onslaughtkneel()
    Attack = true
    NeutralAnims = false
    local orig=WalkSpeed
    WalkSpeed=0
    legAnims=false
    Chat"..."

    
    game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Onslaught]: ...", "All")
    for i = 0, 14, 0.1 do
        
        	WingAnims.Cytus69=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(110+-50*M.C(WingSine/50))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(90+-50*M.C(WingSine/50))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1,1.5)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(180+0*M.C(WingSine/32))),.2)

	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(-110+50*M.C(WingSine/50))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(-90+50*M.C(WingSine/50))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,0,1.5)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-0-0*M.C(WingSine/32))),.2)
		--SPIN
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
	end
        
        swait()
        local Alpha = .1
 					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.4+.05*M.C(Sine/32),0)*CF.A(M.R(-20+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.05*M.S(Sine/32),-0.5)*CF.A(-4.6,M.R(5+10*M.C(Sine/32)),M.R(40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.05*M.S(Sine/32),-0.5)*CF.A(-4.6,M.R(5-10*M.C(Sine/32)),M.R(-40+5*M.C(Sine/32))),Alpha)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-65),-0.2,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.4-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(7),0),Alpha)
    end
    
    		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})



								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
					
													Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(700,700,700);
					}
								Effect{
				Lifetime=3;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,20,400);
					}
		end
	end)()
    
        for i = 0, 3, 0.1 do



            
        swait()
        local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-140-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(140+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
						
						            
  
		end

                    WingAnims.Cytus69=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(110+-50*M.C(WingSine/50))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(90+-50*M.C(WingSine/50))),.2)
    LWP3W.C0 = LWP3W.C0:lerp(CF.N(-2.3,1.3,-1.0)*CF.A(M.R(250+0*M.C(WingSine/32)),7.0,M.R(-60+0*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(-110+50*M.C(WingSine/50))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(-90+50*M.C(WingSine/50))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(1.0,0.3,-2.5)*CF.A(M.R(-290+0*M.C(WingSine/32)),-7.0,M.R(60+0*M.C(WingSine/32))),.2)
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-4)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
    end

    legAnims=true
    WalkSpeed=orig
    Attack = false
    NeutralAnims = true
end


function onslaughtthrow()
    Attack = true
    NeutralAnims = false
    local orig=WalkSpeed
    WalkSpeed=0
    legAnims=false
    Chat"Aim and throw!"

    
    game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Onslaught]: DIE!", "All")
    for i = 0, 14, 0.1 do
        
        swait()
        local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+.05*M.C(Sine/32),0)*CF.A(M.R(5+1*M.S(Sine/64)),M.R(0),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.4,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-2.6,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.1)*CF.A(-0.5,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.6)*CF.A(0.3,M.R(-20),0.1),Alpha)
    end
    
        coroutine.wrap(function()
        for i = 0, 5 do
            Camshake({
                Duration=.2;
                FadeOut=.4;
                Intensity=1.5;
                Position=Vector3.new(.5,.5,.5);
                Rotation=Vector3.new(.5,.5,3);
                DropDist=15;
                IneffectiveDist=40;
                Origin=Root.CFrame*CF.N(0,0,-4-i*4);
            })
            SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
            AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
                DamageColor=PrimaryColor;
                MinimumDamage=25;
                MaximumDamage=45;
            })
        end
    end)()
    
        for i = 0, 3, 0.1 do

                    WingAnims.Cytus69=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(110+-50*M.C(WingSine/50))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(90+-50*M.C(WingSine/50))),.2)
    LWP3W.C0 = LWP3W.C0:lerp(CF.N(-2.3,100.3,0)*CF.A(M.R(250+0*M.C(WingSine/32)),6.0,M.R(-60+0*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(-110+50*M.C(WingSine/50))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(-90+50*M.C(WingSine/50))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(1.0,99.3,0)*CF.A(M.R(-290+0*M.C(WingSine/32)),-6.0,M.R(60+0*M.C(WingSine/32))),.2)
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-4)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
    end

            
        swait()
        local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+.05*M.C(Sine/32),0)*CF.A(M.R(-10+1*M.S(Sine/64)),M.R(0),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.4,M.R(20+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1,M.R(-0-5*M.C(Sine/32)),M.R(-20+5*M.C(Sine/32))),Alpha)
              						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.5)*CF.A(-0.5,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.6)*CF.A(0.2,M.R(-20),0.1),Alpha)
						
		end

                    WingAnims.Cytus69=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(110+-50*M.C(WingSine/50))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(90+-50*M.C(WingSine/50))),.2)
    LWP3W.C0 = LWP3W.C0:lerp(CF.N(-2.3,1.3,-1.0)*CF.A(M.R(250+0*M.C(WingSine/32)),7.0,M.R(-60+0*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(-110+50*M.C(WingSine/50))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1,3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(-90+50*M.C(WingSine/50))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(1.0,0.3,-2.5)*CF.A(M.R(-290+0*M.C(WingSine/32)),-7.0,M.R(60+0*M.C(WingSine/32))),.2)
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-4)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
    end

    legAnims=true
    WalkSpeed=orig
    Attack = false
    NeutralAnims = true
end



	function askwhytaunt()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat4"Hey."
	for i = 0, 10, 0.1 do
		swait()
		local Alpha = .1
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.5*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(0-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-1,0.2-0.1*M.C(Sine/32),-0.6)*CF.A(0,M.R(-5),1.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(1,0.2+0.1*M.C(Sine/32),-0.6)*CF.A(0,M.R(-5),-1.4),Alpha)
	end
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(89,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})
		end
	end)()
			Chat4"Whats wrong?"
		for i = 0, 10, 0.1 do
		swait()
		local Alpha = .1
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.5*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(150+5*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-1,0.2-0.1*M.C(Sine/32),-0.6)*CF.A(0,M.R(-5),1.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(1,0.2+0.1*M.C(Sine/32),-0.6)*CF.A(0,M.R(-5),-1.4),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function defaultt()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	for i = 0, 5, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-230-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(230+0*M.C(Sine/32))),Alpha)
  						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.5)*CF.A(-0.5,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.6)*CF.A(0.2,M.R(-20),0.1),Alpha)
	end
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})



								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
					
													Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(700,700,700);
					}
								Effect{
				Lifetime=3;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,20,400);
					}
		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-140-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(140+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function shatter()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"S H A T T E R"
	for i = 0, 5, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-230-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(230+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
	end
	
		coroutine.wrap(function()
		for i = 0, 0 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})
																Effect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(100,2,100);
					}
                    swait(0.3)
		
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
		
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
		
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
		
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
		
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
		
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
		
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
		
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)
													Effect{
					Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2500,1);
					EndSize=Vector3.new(30,2500,30);
					}
                    swait(0.3)

																Effect{
					Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(600,600,600);
					}
                    swait(0.3)
                    																Effect{
					Lifetime=1.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(700,700,700);
					}
                    swait(0.3)
		end
	end)()
	
		for i = 0, 2, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-140-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(140+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end


	function infinitysnap()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"You shouldve gone for the head"
	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
              					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0*M.C(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(2.7,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
	end
	
		coroutine.wrap(function()
		for i = 0, 0 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})
			
			
								
					
Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(3, 0.01, 3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
wait(0.1)
Effect({
Color = Color3.fromRGB(255, 103, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(3, 0.01, 3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
wait(0.1)
Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(3, 0.01, 3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
wait(0.1)

Effect({
Color = Color3.fromRGB(30, 179, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(3, 0.01, 3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
wait(0.1)
Effect({
Color = Color3.fromRGB(0, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(3, 0.01, 3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
wait(0.1)
Effect({
Color = Color3.fromRGB(255, 0, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(3, 0.01, 3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
wait(0.1)

			
								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
					
													Effect{
				Lifetime=2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(800,800,800);
					}
								Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,10,400);
					}

					   
					


		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
              					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0*M.C(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.6+.05*M.S(Sine/32),0)*CF.A(2.7,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end


--[[]]



	function powerattack()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"WELCOME TO THE BEGINNING OF THE END"
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[CALAMITY]: WELCOME TO THE BEGINNING OF THE END!", "All")
	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-230-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(230+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
	end
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})



								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
								Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,50,400);
					}
		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-140-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(140+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function powerattack1()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"I AM THE LIMITLESS!"
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[Limitless]: I AM THE LIMITLESS!!", "All")
	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-230-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(230+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
	end
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})



								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
								Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,50,400);
					}
		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-140-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(140+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function GLITCHTAUNT()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"Immaculate."
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("Immaculate...", "All")
	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1+0.05*M.C(Sine/32),0)*CF.A(M.R(-40+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-5-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
	LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(- 40+0*M.S(Sine/32)),M.R(15+0*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
	RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.2+.08*M.S(Sine/32),-0.3)*CF.A(M.R(40+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(20+10*M.C(Sine/1))),Alpha)
	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1-.05*M.C(Sine/32),-1)*CF.A(M.R(40-3*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),-0.0+0*M.C(Sine/32)),Alpha)
	RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-1.2)*CF.A(M.R(-20-3*M.S(Sine/32)),M.R(-5+0*M.C(Sine/32)),0.0+0*M.C(Sine/32)),Alpha)
				
	end
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(3802269741,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})



								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
								Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,50,400);
					}
		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
                   RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+0.0*M.C(Sine/32),0)*CF.A(M.R(-40+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
	LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(- 40+0*M.S(Sine/32)),M.R(15+0*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
	RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-1.3+.08*M.S(Sine/32),-0.3)*CF.A(M.R(40+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(20+10*M.C(Sine/1))),Alpha)
	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1-.05*M.C(Sine/32),-1)*CF.A(M.R(40-3*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),-0.0+0*M.C(Sine/32)),Alpha)
	RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-1.2)*CF.A(M.R(-20-3*M.S(Sine/32)),M.R(-5+0*M.C(Sine/32)),0.0+0*M.C(Sine/32)),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end


	function MAYHEMMOMENT()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=true
	--Chat""
	for i = 0, 14, 0.1 do
		
	
		
		swait(0)
		local Alpha = .1
	RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+0*M.C(Sine/32),0)*CF.A(M.R(-30+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-0*(Sine/1)),M.R(-5+50*M.C(Sine/1)),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(30-10*M.C(Sine/2))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-30+10*M.C(Sine/2))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/64),0)*CF.A(M.R(60+0*M.S(Sine/64)),M.R(-0),-0.0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/64),0)*CF.A(M.R(60+0*M.S(Sine/64)),M.R(-0),0.0),Alpha)
					
		end
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(3802269741,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})



								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
								Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,50,400);
					}
		end
	end)()
	
		for i = 0, 6, 0.1 do
		
		
		
		swait(0.0)
		local Alpha = .1
RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+0.0*M.C(Sine/64),0)*CF.A(M.R(30+0*M.S(Sine/64)),M.R(0),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(45-0*M.S(Sine/32)),M.R(-5+45*M.S(Sine/1)),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.0,0.3+.0*M.S(Sine/32),-0)*CF.A(-0.2,M.R(0-0*M.C(Sine/32)),M.R(-145+5*M.C(Sine/5))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.0,0.3+.0*M.S(Sine/32),-0)*CF.A(-0.2,M.R(0-0*M.C(Sine/32)),M.R(145+5*M.C(Sine/5))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.0*M.C(Sine/64),0)*CF.A(M.R(-60+0.0*M.S(Sine/64)),M.R(-0),-0.0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.0*M.C(Sine/64),0)*CF.A(M.R(-40+0.0*M.S(Sine/64)),M.R(-0),0.0),Alpha)
				

	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

function Justice()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=30
	legAnims=true
	Chat"【Ｊｕｓｔｉｃｅ】: I am the one who serves justice!."
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("【Ｊｕｓｔｉｃｅ】: I am the one who serves justice!", "All")
	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,60+1*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(10),-0.3+-0.1*M.C(Sine/32)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.4+.2*M.S(Sine/32),0)*CF.A(1.2,M.R(5+5*M.C(Sine/32)),M.R(-30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,-0.2+.2*M.S(Sine/32),0)*CF.A(0.0,M.R(5-5*M.C(Sine/32)),M.R(-60+5*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5,M.R(15),0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.8)*CF.A(-0.2,M.R(-15),0.1),Alpha)
	
		end
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})

		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.1+.1*M.C(Sine/32),0)*CF.A(M.R(-15+1*M.S(Sine/64)),M.R(0),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-0-0.0*M.S(Sine/32)),M.R(35),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0.6+.1*M.S(Sine/32),-0.3)*CF.A(3.2,M.R(10-2*M.C(Sine/30)),M.R(40+1*M.C(Sine/28))),Alpha)
						RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.1+.1*M.S(Sine/32),0)*CF.A(-0.0,M.R(0-0*M.C(Sine/math.random(1,15))),M.R(25+0*M.C(Sine/math.random(1,15)))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.1,-0.3-.1*M.C(Sine/32),-0.1)*CF.A(0.8,M.R(55),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.1,-0.1-.1*M.C(Sine/32),-0.1)*CF.A(-0.3,M.R(-30),0.3),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

function CORRUPTION1()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"[CORRUPTION]: Stomp."
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[CORRUPTION]: Stomp.", "All")
	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
 RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.1*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-0),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-0-0.0*M.S(Sine/32)),M.R(-0),25),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.0*M.S(Sine/32),0)*CF.A(2,M.R(5+0*M.C(Sine/32)),M.R(-10-0*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.0*M.S(Sine/32),0)*CF.A(2,M.R(5-0*M.C(Sine/32)),M.R(10+0*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.0,0-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(35),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.0,1.9-.05*M.C(Sine/32),-0.2)*CF.A(0.5,M.R(-45),0.2),Alpha)
		end
	
	           
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})



								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
								Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,50,400);
					}
		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
 RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.1*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-0),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-0-0.0*M.S(Sine/32)),M.R(-0),25),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.0,0-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(35),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.0,0.0-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(-45),0.2),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

function CORRUPTION2()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"[CORRUPTION]: How'd you like that?"
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[CORRUPTION]: How'd you like that?", "All")
	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
 RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.1*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-0),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-0-0.0*M.S(Sine/32)),M.R(-0),25),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.0*M.S(Sine/32),0)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-10-0*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.0*M.S(Sine/32),0)*CF.A(1,M.R(5-0*M.C(Sine/32)),M.R(10+0*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.0,0-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(35),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.0,0.0-.05*M.C(Sine/32),-0.2)*CF.A(0.0,M.R(-45),0.2),Alpha)
		end
	
	           
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})



								
		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
 RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.1*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-0),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-0-0.0*M.S(Sine/32)),M.R(-0),25),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.0,0-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(35),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.0,0.0-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(-45),0.2),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function MAYHEMMOMENT2()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"[MAYHEM]: THIS IS IT!"
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[MAYHEM]: THIS IS IT!", "All")
	for i = 0, 14, 0.1 do
		swait()
local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-230-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(230+0*M.C(Sine/32))),Alpha)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.0,0.,M.R(-5.5)),Alpha)
					RH.C0 = RH.C0:lerp(LHC0*CF.N(1,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.0,0.,M.R(-5.5)),Alpha)
	end
	
		coroutine.wrap(function()
		for i = 0, 1 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(1690475123,1,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})


				Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(100, 0, 255),
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(150,10,150);
					}
					
									Effect{
				Lifetime=1.5;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(100, 0, 255),
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(150,10,150);
					}
					
									
																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

									
																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})




		end
	end)()
	
		for i = 0, 2, 0.5 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(-45+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.2+.25*M.C(Sine/0.5),0)*CF.A(M.R(-45+1*M.S(Sine/64)),M.R(0),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function eternalslam()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"ETERNAL SLAM!"
--	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[ETERNAL]: ETERNAL SLAM!!", "All")
	for i = 0, 3, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-230-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(230+0*M.C(Sine/32))),Alpha)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.95,0.,M.R(-5.5)),Alpha)
					RH.C0 = RH.C0:lerp(LHC0*CF.N(1,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.95,0.,M.R(-5.5)),Alpha)
	end
	
		coroutine.wrap(function()
		for i = 0, 1 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})


				Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(100, 0, 255),
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(150,10,150);
					}
					
									Effect{
				Lifetime=1.5;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(100, 0, 255),
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(150,10,150);
					}
					
									
																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

									
																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})




		end
	end)()
	
		for i = 0, 2, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(-45+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.2+.25*M.C(Sine/0.5),0)*CF.A(M.R(-45+1*M.S(Sine/64)),M.R(0),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function virusspread()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"Let the virus spread.."
--	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[ETERNAL]: ETERNAL SLAM!!", "All")
	for i = 0, 3, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-230-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(230+0*M.C(Sine/32))),Alpha)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.95,0.,M.R(-5.5)),Alpha)
					RH.C0 = RH.C0:lerp(LHC0*CF.N(1,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.95,0.,M.R(-5.5)),Alpha)
	end
	
		coroutine.wrap(function()
		for i = 0, 1 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})


				Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(150,10,150);
					}
					
									Effect{
				Lifetime=1.5;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(150,10,150);
					}
					
																												Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}																												Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}																												Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}																												Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}
																																	Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}																												Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}																												Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}																												Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}
																																	Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}																												Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}																												Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}																												Effect{
				Lifetime=1.8;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-50,50),math.random(-20,20),math.random(-50,50)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}
					
									
																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

									
																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
                    Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 1.5,
})




		end
	end)()
	
		for i = 0, 2, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(-45+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.2+.25*M.C(Sine/0.5),0)*CF.A(M.R(-45+1*M.S(Sine/64)),M.R(0),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function hyperpower()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"WELCOME TO THE BEGINNING OF THE END"
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[HYPERSKIDDED]: 🤡🕶P0WE3R✌😊  HYPER👼😐%HeLp%😔😐 Sk1DDed*💖😃", "All")
	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.4+.05*M.C(Sine/32),0)*CF.A(M.R(-20+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(30-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-30+10*M.C(Sine/1))),Alpha)
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-65),-0.2,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.4-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(7),0),Alpha)
	end
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})



								Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,600,600);
					}
								Effect{
				Lifetime=1.7;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(400,50,400);
					}
		end
	end)()
	
		for i = 0, 6, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+.05*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+0*M.C(Sine/32)),M.R(-140-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-0*M.C(Sine/32)),M.R(140+0*M.C(Sine/32))),Alpha)
                	LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function boomhacker()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false

	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+0*M.C(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
		    		LS.C0 = LS.C0:lerp(LSC0*CF.N(.4,-.2+.05*M.S(Sine/32),.3)*CF.A(M.R(-30),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.8,M.R(5-5*M.C(Sine/32)),M.R(-30+5*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.3)*CF.A(0,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.3)*CF.A(0,M.R(-20),0.1),Alpha)
	end
	Chat"Hey! Call in an airstrike!"
	wait(3)
    Chat"~*Alight one is comin in!*~"
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[HOLOGRAPHIC]: CALL IN AN AIRSTRKE", "All")
	
		coroutine.wrap(function()
		for i = 0, 5 do
			Camshake({
			    Duration=.2;
				FadeOut=.4;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(551132916,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})
			Effect{
				Lifetime=1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,600,1);
					EndSize=Vector3.new(50,600,50);
					}
					
								Effect{
				Lifetime=3;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(600,10,600);
					}
					
													Effect{
				Lifetime=2;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(300,300,300);
					}
		end
	end)()
		for i = 0, 4, 0.1 do
		swait()
		local Alpha = .1
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+0*M.C(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
		    		LS.C0 = LS.C0:lerp(LSC0*CF.N(.4,-.2+.05*M.S(Sine/32),.3)*CF.A(M.R(-30),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.3)*CF.A(0,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.3)*CF.A(0,M.R(-20),0.1),Alpha)
	end
	

	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function susvent()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=50
	legAnims=false

	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("In the vent", "All")
	for i = 0, 4, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(1,0+.05*M.S(Sine/32),1)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-0-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-1,0+.05*M.S(Sine/32),1)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(0+0*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1.3-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(30),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.3-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(-30),0.1),Alpha)
	end
	
		for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-8+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(1,0+.05*M.S(Sine/32),1)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-0-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-1,0+.05*M.S(Sine/32),1)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(0+0*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(30),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(-30),0.1),Alpha)
		end
    wait(10)
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end

	function powertaunt()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false

	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[POWER]: What are you going to do?", "All")
	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-140-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0.1),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end


	function withertaunt()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"Fading away."
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer("[WITHERED]: Fading Away.", "All")

	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(30-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-30+10*M.C(Sine/1))),Alpha)
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.7)*CF.A(-0.4,M.R(-5),0),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end



	function VaporTaunt()
		Attack = true
		NeutralAnims = false
		local orig=WalkSpeed
		WalkSpeed=0
		legAnims=false
		Chat"You need to chill out.."
		for i = 0, 14, 0.1 do
			swait()
			local Alpha = .1
			RJ.C0 = RJ.C0:lerp(CF.N(-0.1,-0.1-.1*M.S(Sine/36),0.6)*CF.A(M.R(55.3+2.5*M.C(Sine/36)),M.R(0),M.R(0)),Alpha)
			LH.C0 = LH.C0:lerp(CF.N(-0.6,-1.2,-0.1)*CF.A(M.R(56.3+10*M.C(Sine/36)),M.R(0),M.R(24)),Alpha)
			RH.C0 = RH.C0:lerp(CF.N(0.9,-1.2,-0.2)*CF.A(M.R(25+5*M.C(Sine/36)),M.R(3.5),M.R(-43.9)),Alpha)
			LS.C0 = LS.C0:lerp(CF.N(-1,0.8,0)*CF.A(M.R(11.4-5*M.C(Sine/42)),M.R(-3.3),M.R(137.5)),Alpha)
			RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,-0.2)*CF.A(M.R(61-5*M.C(Sine/42)),M.R(0),M.R(0)),Alpha)
			NK.C0 = NK.C0:lerp(CF.N(0,1.4,-0.3)*CF.A(M.R(-38.9-5*M.C(Sine/42)),M.R(0),M.R(0)),Alpha)
		end
		legAnims=true
		WalkSpeed=orig
		Attack = false
		NeutralAnims = true
	end



	UIS.InputBegan:connect(function(io,gpe)
		if(gpe or Attack or data.User~=data.Local)then return end
		--MODES
		if(io.KeyCode == Enum.KeyCode.One and Mode~='CHOICE')then 
			changeMode'CHOICE'
			game.Lighting.FogEnd = 999999999
		    game.Lighting.FogColor = Color3.new(1, 1, 1)
			Chat7"I lost a part of myself I can never get back."
			music.Pitch = 1
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Two and Mode~='Forgotten')then 
			changeMode'Forgotten'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Was there a time where I was important?"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Three and Mode~='サイコ')then 
			changeMode'サイコ'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"You'd never match to my speed!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.C and Mode=='P A I N')then 
			changeMode'Eradicating'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 100
		    Chat4"What was the point of existing in the first place..?"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='サイコ')then 
			changeMode'REPRECAUTION'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Lets see how far I can go!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='CHOICE')then 
			changeMode'DARK'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"You didn't even have a choice to live."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.One and Mode~='CHOICE')then 
			changeMode'CHOICE'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"You have the choice to go to the rightous side or the dark side."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Seven and Mode~='CORROSION')then 
			changeMode'CORROSION'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"ACIDC BURST!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='CORROSION')then 
			changeMode'EARTHQUAKE'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"THE EARTH QUAKES BELOW ME!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Four and Mode~='COLLAPSED')then 
			changeMode'COLLAPSED'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"I can't feel myself."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='REDEMPTION')then 
			changeMode'EMPERATOR'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 500
		    Chat4"=D"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Five and Mode~='ERR0R')then 
			changeMode'ERR0R'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"The world will fall into my hands."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Six and Mode~='WARP')then 
			changeMode'WARP'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Obsolete, you are."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Nine and Mode~='PSYCHIC')then 
			changeMode'PSYCHIC'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Let ME test you."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='PSYCHIC')then 
			changeMode'CONTROLLED'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"I can control you whenever I want (="
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='Forgotten')then 
			changeMode'LOST'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Where am i? Please help me!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Eight and Mode~='FLAME')then 
			changeMode'FLAME'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"BLAZING HOT FIRE!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Zero and Mode~='XENOPHERIC')then 
			changeMode'XENOPHERIC'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"I have all knowledge of everything. Even if something has been created."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='XENOPHERIC')then 
			changeMode'P A I N'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"BURN"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='WARP')then 
			changeMode'CORRODE'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"I can see everything corroded, into bits..."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='P A I N')then 
			changeMode'NEAR DEATH'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"I can't TAKE IT ANYMORE."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.F and Mode~='V E L D U S')then 
			changeMode'V E L D U S'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"BURN IN HELL YOU FREAK!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Z and Mode~='C O M P L E X')then 
			changeMode'C O M P L E X'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Time and gravity shall me COMPLEX."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.X and Mode~='F A L L E N')then 
			changeMode'F A L L E N'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"I have fallen into the sinning of this cursed world..."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.Q and Mode~='Damaged')then 
			changeMode'Damaged'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Everything... It sure does look perfect!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.E and Mode~='SANCTUARY')then 
			changeMode'SANCTUARY'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Now now, let's see if you can fight."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.C and Mode~='REDEMPTION')then 
			changeMode'REDEMPTION'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"There are chances I can take to BEAT them."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.J and Mode~='APEX')then 
			changeMode'APEX'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Outta my way!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.L and Mode~='GLITCHED')then 
			changeMode'GLITCHED'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Get out of here, you don't want to be killed now."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.K and Mode~='Expitition')then 
			changeMode'Expitition'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"I'll change this whole society myself."
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.R and Mode~='Pyro')then 
			changeMode'Pyro'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Get into the fire..!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='APEX')then 
			changeMode'VIRTUE'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Outta my way!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='FLAME')then 
			changeMode'CRAZED'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"Get into the freezing ice!"
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end

elseif(io.KeyCode == Enum.KeyCode.T and Mode=='ERR0R')then 
			changeMode'LEXUS ERR0R'
			game.lighting.ClockTime = 14
			game.lighting.FogEnd = 999999999
		    Chat4"You tried, didn't you? (="
		if voicelines == false then
else
end
if voicelines == true then
game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("THE", "All")
else
end
	
			--TOGGLE MUSIC
		elseif(io.KeyCode == Enum.KeyCode.M and getMode(Mode))then 
			MusicMode=MusicMode+1
			if(MusicMode>3)then MusicMode=1 end
			if(MusicMode==1)then
				music:Pause()
				music.Volume=5
				music.Parent=Torso
				music:Resume()
			elseif(MusicMode==2)then
				music:Pause()
				music.Volume=5
				music.Parent=Char
				music:Resume()
			elseif(MusicMode==3)then
				music.Volume = 0
			end
		elseif(io.KeyCode==Enum.KeyCode.B)then
			--TAUNTS
			if(vaporwaveMode and Mode=='Troubadour')then
				VaporTaunt()
			end
		end

if(io.KeyCode==Enum.KeyCode.One)then
		--TAUNTS
		if(Mode=='CHOICE')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.F)then
		--TAUNTS
		if(Mode=='V E L D U S')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.Z)then
		--TAUNTS
		if(Mode=='C O M P L E X')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.X)then
		--TAUNTS
		if(Mode=='F A L L E N')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.Q)then
		--TAUNTS
		if(Mode=='Damaged')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.J)then
		--TAUNTS
		if(Mode=='APEX')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.L)then
		--TAUNTS
		if(Mode=='GLITCHED')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.K)then
		--TAUNTS
		if(Mode=='Expitition')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.R)then
		--TAUNTS
		if(Mode=='Pyro')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.C)then
		--TAUNTS
		if(Mode=='REDEMPTION')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.E)then
		--TAUNTS
		if(Mode=='SANCTUARY')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.Two)then
		--TAUNTS
		if(Mode=='Forgotten')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.T)then
		--TAUNTS
		if(Mode=='VIRTUE')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.Three)then
		--TAUNTS
		if(Mode=='CHINESE')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.Four)then
		--TAUNTS
		if(Mode=='COLLAPSED')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.T)then
		--TAUNTS
		if(Mode=='EMPERATOR')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.Five)then
		--TAUNTS
		if(Mode=='ERR0R')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.Six)then
		--TAUNTS
		if(Mode=='WARP')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.Zero)then
		--TAUNTS
		if(Mode=='XENOPHERIC')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.T)then
		--TAUNTS
		if(Mode=='P A I N')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.Seven)then
		--TAUNTS
		if(Mode=='CORROSION')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.T)then
		--TAUNTS
		if(Mode=='EARTHQUAKE')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.Eight)then
		--TAUNTS
		if(Mode=='FLAME')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.T)then
		--TAUNTS
		if(Mode=='CRAZED')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.T)then
		--TAUNTS
		if(Mode=='LEXUS ERR0R')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.Nine)then
		--TAUNTS
		if(Mode=='PSYCHIC')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.T)then
		--TAUNTS
		if(Mode=='CONTROLLED')then
			MAYHEMMOMENT()
		end
end

if(io.KeyCode==Enum.KeyCode.G)then
		--TAUNTS
		if(Mode=='GLITCHED')then
			GLITCHTAUNT()
		end
end









		
		if(vaporwaveMode)then return end
		--ATTACKS
		if(io.UserInputType==Enum.UserInputType.MouseButton1)then
			ClickCombo()
		end
	end)
	
	WingAnims.Cytus125=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(4,-100,-1)*CF.A(M.R(6+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(8.25,-100,-1)*CF.A(M.R(13+15*M.C(WingSine/32)),0,M.R(15+7.5*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(12.5,-100,-1)*CF.A(M.R(28+20*M.C(WingSine/32)),0,M.R(30+9*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-4,-2,-1)*CF.A(M.R(6+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-8.2,-2,-1+.05*M.S(WingSine/35))*CF.A(M.R(13+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-12.1,-2,-1)*CF.A(M.R(28+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/32))),.2)
		--SPIN
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
	end
	
	WingAnims.Destiny=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(4,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(8.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+7.5*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(12.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+9*M.C(WingSine/32))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-4,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-8.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-12.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/32))),.2)
		--SPIN
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
	end
	
			WingAnims.KRAZY=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5+.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/36),M.R(90+3000*M.C(WingSine/100))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5+.75*M.C(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/37),M.R(147.5+3000*M.C(WingSine/100))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5-.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/51),M.R(32.5+3000*M.C(WingSine/100))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5-.75*M.C(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/36),M.R(-90+3000*M.C(WingSine/100))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5+.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/37),M.R(-147.5+3000*M.C(WingSine/100))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(2+2.5*M.C(WingSine/180),1.5+.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/51),M.R(-32.5+3000*M.C(WingSine/100))),.2)
    	--SPIN
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
			end
	
				WingAnims.KRAZY2=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(20+4.5*M.C(WingSine/180),1.5+.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/36),M.R(90+3000*M.C(WingSine/2000))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(20+4.5*M.C(WingSine/180),1.5+.75*M.C(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/37),M.R(147.5+3000*M.C(WingSine/2000))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(20+4.5*M.C(WingSine/180),1.5-.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/51),M.R(32.5+3000*M.C(WingSine/2000))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(20+4.5*M.C(WingSine/180),1.5-.75*M.C(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/36),M.R(-90+3000*M.C(WingSine/2000))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(20+4.5*M.C(WingSine/180),1.5+.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/37),M.R(-147.5+3000*M.C(WingSine/2000))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(20+4.5*M.C(WingSine/180),1.5+.75*M.S(WingSine/25),-1)*CF.A(0,0-0*M.C(WingSine/51),M.R(-32.5+3000*M.C(WingSine/2000))),.2)
    	--SPIN
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
				end
				
		WingAnims.Sword1=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-0.3,1,2)*CF.A(M.R(-90+0*M.C(WingSine/32)),3.23,M.R(-100+0*M.C(WingSine/32))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+400*M.C(WingSine/32))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/50))),.2)

		RWP1W.C0 = RWP1W.C0:lerp(CF.N(-0.3,6,2)*CF.A(M.R(-90+0*M.C(WingSine/32)),3.23,M.R(-100+0*M.C(WingSine/32))),.2)
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-400*M.C(WingSine/32))),.2)
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,3,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/50))),.2)
		--SPIN
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
		end
	
WingAnims.Cytus114=function()
			LWP1W.C0 = LWP1W.C0:lerp(CF.N(20+10*M.C(WingSine/36),3+2*M.C(WingSine/36),-2)*CF.A(0,M.R(45+2.5*M.C(WingSine/36)),M.R(120+5000*M.C(WingSine/400)))*CF.A(18.8,M.R(2),0)*CF.N(-0-5*M.C(WingSine/36),-0-5*M.C(WingSine/36),0),.2)
			LWP2W.C0 = LWP2W.C0:lerp(CF.N(20+10*M.C(WingSine/36),3+2*M.C(WingSine/36),-2)*CF.A(0,M.R(45+2.5*M.C(WingSine/36)),M.R(240+5000*M.C(WingSine/400)))*CF.A(18.8,M.R(2),0)*CF.N(-0-5*M.C(WingSine/36),-0-5*M.C(WingSine/36),0),.2)
			LWP3W.C0 = LWP3W.C0:lerp(CF.N(20+10*M.C(WingSine/36),3+2*M.C(WingSine/36),-2)*CF.A(0,M.R(45+2.5*M.C(WingSine/36)),M.R(360+5000*M.C(WingSine/400)))*CF.A(18.8,M.R(2),0)*CF.N(-0-5*M.C(WingSine/36),-0-5*M.C(WingSine/36),0),.2)

			RWP1W.C0 = RWP1W.C0:lerp(CF.N(20+10*M.C(WingSine/36),3+2*M.C(WingSine/36),-2)*CF.A(0,M.R(-45+2.5*M.C(WingSine/36)),M.R(120+5000*M.C(WingSine/400)))*CF.A(18.8,M.R(2),0)*CF.N(-0+5*M.C(WingSine/36),0+5*M.C(WingSine/36),0),.2)
			RWP2W.C0 = RWP2W.C0:lerp(CF.N(20+20*M.C(WingSine/36),3+2*M.C(WingSine/36),-2)*CF.A(0,M.R(-45+2.5*M.C(WingSine/36)),M.R(240+5000*M.C(WingSine/400)))*CF.A(18.8,M.R(2),0)*CF.N(-0+5*M.C(WingSine/36),0+5*M.C(WingSine/36),0),.2)
			RWP3W.C0 = RWP3W.C0:lerp(CF.N(20+20*M.C(WingSine/36),3+2*M.C(WingSine/36),-2)*CF.A(0,M.R(-45+2.5*M.C(WingSine/36)),M.R(360+5000*M.C(WingSine/400)))*CF.A(18.8,M.R(2),0)*CF.N(-0+5*M.C(WingSine/36),0+5*M.C(WingSine/36),0),.2)
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
				end
	
	WingAnims.isgonnahappensoon=function()
		LWP1W.C0 = LWP1W.C0:lerp(CF.N(-0,5,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+-400*M.C(WingSine/300))),.2)
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-0,10+3*M.C(WingSine/60),-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+400*M.C(WingSine/300))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-0,15+-3*M.C(WingSine/60),-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(89+-400*M.C(WingSine/300))),.2)

			RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,5,-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+-400*M.C(WingSine/300))),.2)
			RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,10+3*M.C(WingSine/60),-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+400*M.C(WingSine/300))),.2)
			RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,15+-3*M.C(WingSine/60),-1)*CF.A(M.R(0+0*M.C(WingSine/32)),0,M.R(-89+-400*M.C(WingSine/300))),.2)
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
	end

	WingAnims.Cytus92=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(48+5*M.C(WingSine/64))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(230+5*M.C(WingSine/64))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0.3,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(270+5*M.C(WingSine/64))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(315+-5*M.C(WingSine/64))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(130+-5*M.C(WingSine/64))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0.0,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(90+-5*M.C(WingSine/64))),.2)
	
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
	end
	
	WingAnims.VELDUS=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(48+5*M.C(WingSine/64))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(270+5*M.C(WingSine/64))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0.3,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(230+5*M.C(WingSine/64))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(315+-5*M.C(WingSine/64))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(90+-5*M.C(WingSine/64))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0.0,4+1.0*M.C(WingSine/64),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(130+-5*M.C(WingSine/64))),.2)
	
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
	end
	
	WingAnims.Archsword=function()
		LWP1W.C0 = LWP2W.C0:lerp(CF.N(-3+3*M.C(WingSine/32),3,-1)*CF.A(M.R(25+5*M.C(WingSine/32)+0*M.C(WingSine/32)),0,M.R(-90+-50*(WingSine/64))),1) -- DemonGodSword
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-3+3*M.C(WingSine/32),9,-1)*CF.A(M.R(25+5*M.C(WingSine/32)+0*M.C(WingSine/32)),0,M.R(-180+-50*(WingSine/64))),1) -- RainbowGodSword
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-3+3*M.C(WingSine/32),3,-1)*CF.A(M.R(25+5*M.C(WingSine/32)),0,M.R(-180+-50*(WingSine/64))),1) -- DemonLordSword

		RWP1W.C0 = RWP2W.C0:lerp(CF.N(-3+3*M.C(WingSine/32),3,-1)*CF.A(M.R(25+5*M.C(WingSine/32)),0,M.R(90+-50*(WingSine/64))),1) -- AuroraSword
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-3+3*M.C(WingSine/32),9,-1)*CF.A(M.R(25+5*M.C(WingSine/32)),0,M.R(0+-50*(WingSine/64))),1) -- VoidLordSword
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-3+3*M.C(WingSine/32),3,-1)*CF.A(M.R(25+5*M.C(WingSine/32)),0,M.R(0+-50*(WingSine/64))),1) -- CorruptLordSword
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
	end



--

				WingAnims.Cytus109=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(1+3*M.C(WingSine/30),3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(70+-50*M.C(WingSine/50))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(1+3*M.C(WingSine/30),3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(90+-50*M.C(WingSine/50))),.2)
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,-2,-0)*CF.A(M.R(80+0*M.C(WingSine/32)),0,M.R(70+2*M.C(WingSine/1))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-1+-3*M.C(WingSine/30),3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(-70+50*M.C(WingSine/50))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-1+-3*M.C(WingSine/30),3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(-90+50*M.C(WingSine/50))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-100+3*M.C(WingSine/30),3+3*M.C(WingSine/30),-1)*CF.A(M.R(20+0*M.C(WingSine/50)),0,M.R(-110+50*M.C(WingSine/50))),.2)
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
		end

			WingAnims.PSYCHIC=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(3,5+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(60+1000*M.C(WingSine/400))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(-3,5+-6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(120+1000*M.C(WingSine/400))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(3,5+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(180+1000*M.C(WingSine/400))),.2)
	 
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-3,5+-6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(240+1000*M.C(WingSine/400))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(3,5+6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(300+1000*M.C(WingSine/400))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-3,5+-6*M.C(WingSine/32),-1)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(360+1000*M.C(WingSine/400))),.2)
	
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0+0*M.C(WingSine/62),-0.0+0*M.S(WingSine/42),-0)*CF.A(0,0,M.R(45-0*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
		end



WingAnims.JUDGEMENT=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/28),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(190+200*M.C(WingSine/64))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/28),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(230+300*M.C(WingSine/64))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0.3,4+1.0*M.C(WingSine/28),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(270+400*M.C(WingSine/64))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,9+1.0*M.C(WingSine/28),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(190+200*M.C(WingSine/64))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,9+1.0*M.C(WingSine/28),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(230+300*M.C(WingSine/64))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,9+1.0*M.C(WingSine/28),-2)*CF.A(M.R(5+4*M.C(WingSine/50)),0,M.R(270+400*M.C(WingSine/64))),.2)
	
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
	end

WingAnims.WARPER=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/28),-2)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(-190+200*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/28),-2)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(-230+300*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/28),-2)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(-270+400*M.C(WingSine/32))),.2)
	
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/28),-2)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(190+200*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/28),-2)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(230+300*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,4+1.0*M.C(WingSine/28),-2)*CF.A(M.R(0+0*M.C(WingSine/50)),0,M.R(270+400*M.C(WingSine/32))),.2)
	
	RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
	end




--YOURMOTHER



	while true do
		swait()
		ClickTimer=math.max(ClickTimer-1,0)
		if(ClickTimer<=0 and Combo~=1)then
			Combo=1
		end
		Sine=Sine+Change
		hue=hue+1
		if(hue>360)then hue=1 end
		local hitfloor,posfloor = workspace:FindPartOnRayWithIgnoreList(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4)), {Effects,Char,workspace[Player.Name]})
		local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
		local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or (not hitfloor or hitfloor.CanCollide==false) and Root.Velocity.y < -1 and "Fall" or (not hitfloor or hitfloor.CanCollide==false) and Root.Velocity.y > 1 and "Jump" or hitfloor and Walking and "Walk" or hitfloor and "Idle")
		Hum.WalkSpeed = WalkSpeed
		local sidevec = math.clamp((Torso.Velocity*Torso.CFrame.rightVector).X+(Torso.Velocity*Torso.CFrame.rightVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
		local forwardvec =  math.clamp((Torso.Velocity*Torso.CFrame.lookVector).X+(Torso.Velocity*Torso.CFrame.lookVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
		local sidevelocity = sidevec/Hum.WalkSpeed
		local forwardvelocity = forwardvec/Hum.WalkSpeed

		local lhit,lpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(LLeg.CFrame.p,((CFrame.new(LLeg.Position,LLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {Effects,Char,workspace[Player.Name]})
		local rhit,rpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(RLeg.CFrame.p,((CFrame.new(RLeg.Position,RLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {Effects,Char,workspace[Player.Name]})
		if(Mode=='Troubadour' and IsVaporwave(getMode'Troubadour'.Music))then
			vaporwaveMode=true
			text.Text='Ｖａｐｏｒｗａｖｅ'
			WingAnim='NebG3'
		else
			if(Mode=='Troubadour')then
				text.Text='Troubadour'
				WingAnim=getMode'Troubadour'.WingAnim
			end
			vaporwaveMode=false
		end

		if(Mode~='Lust' and WingAnim and WingAnims[WingAnim])then
			WingAnims[WingAnim]()
		elseif(Mode=='Lust')then
			if(State=='Idle')then
				WingAnims.LustFrench()
			else
				WingAnims.NebG3(1)	
			end
		elseif(WingAnim and typeof(WingAnim)=='table' and WingAnims[WingAnim[1]])then
			local gay={unpack(WingAnim)};
			table.remove(gay,1)
			WingAnims[WingAnim[1]](unpack(gay))
		else
			WingAnims.meowldarkXD1()
		end

		if(Mode=='Troubadour' and NeutralAnims)then
			WingSine=WingSine+(0.1+music.PlaybackLoudness/300)
		else
			WingSine=WingSine+1
		end
		
				
			if(Mode~='VISUALIZER' and WingAnim and WingAnims[WingAnim])then
		WingAnims[WingAnim]()
	elseif(Mode=='VISUALIZER')then
		if(State=='Idle')then
			WingAnims.Cytus97()
		else
			WingAnims.EMPTY(1)	
		end

	elseif(WingAnim and typeof(WingAnim)=='table' and WingAnims[WingAnim[1]])then
		local gay={unpack(WingAnim)};
		table.remove(gay,1)
		WingAnims[WingAnim[1]](unpack(gay))
	else
		WingAnims.NebG5()
	end

		if(music)then
			if(Mode=='Lightning Cannon')then
				local clr = Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1))
				local clr2 = Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/950,0,1))
				text.TextColor3 = clr
				PrimaryColor = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
				elseif(Mode=='HYPERSKIDDED')then
				local clr = BrickColor.random().Color
		    	local clr2 = BrickColor.random().Color
				text.TextColor3 = clr
				PrimaryColor = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
								elseif(Mode=='FORMALITY')then
				local clr = BrickColor.random().Color
		    	local clr2 = BrickColor.random().Color
				text.TextColor3 = clr
				PrimaryColor = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
												elseif(Mode=='disturbance')then
				local clr = Color3.fromHSV(hue/360,2,math.clamp(music.PlaybackLoudness/475,0,5))
				local clr2 = Color3.fromHSV(hue/360,2,math.clamp(music.PlaybackLoudness/475,0,5))
				text.TextColor3 = clr
				PrimaryColor = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
																elseif(Mode=='VISUALIZER')then
				local clr = Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1))
				local clr2 = Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/950,0,1))
				text.TextColor3 = clr
				PrimaryColor = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
				
																				elseif(Mode=='My Return')then
				local clr = Color3.fromRGB(10+music.PlaybackLoudness/5, 0, 0)
				local clr2 = Color3.fromRGB(10+music.PlaybackLoudness/5, 0, 0)
				text.TextColor3 = clr
				PrimaryColor = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end	
																				elseif(Mode=='EXECUTION')then
				local clr = Color3.fromHSV(hue/360,1,math.clamp(2,0,1))
				local clr2 = Color3.fromHSV(hue/360,1,math.clamp(2,0,1))
				text.TextStrokeColor3 = clr
				text.TextStrokeColor3 = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
				
																								elseif(Mode=='RAINBOW')then
				local clr = Color3.fromHSV(hue/360,1,math.clamp(2,0,1))
				local clr2 = Color3.fromHSV(hue/360,1,math.clamp(2,0,1))
				text.TextStrokeColor3 = clr
				text.TextStrokeColor3 = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
				
												elseif(Mode=='K A R M A')then
				local clr = BrickColor.random().Color
		    	local clr2 = BrickColor.random().Color
				text.TextColor3 = clr
				PrimaryColor = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
				
																elseif(Mode=='MALWARE')then
				local clr = BrickColor.random().Color
		    	local clr2 = BrickColor.random().Color
				text.TextColor3 = clr
				PrimaryColor = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
				
																elseif(Mode=='PROBLEMATIC')then
				local clr = BrickColor.random().Color
		    	local clr2 = BrickColor.random().Color
				text.TextColor3 = clr
				PrimaryColor = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
																elseif(Mode=='ABNORMALITY')then
				local clr = BrickColor.random().Color
		    	local clr2 = BrickColor.random().Color
				text.TextColor3 = clr
				PrimaryColor = clr2
				for _,v in next, wingModel:GetDescendants() do
					if(v:IsA'BasePart')then
						v.Color = clr2
					elseif(v:IsA'Trail')then
						v.Color = ColorSequence.new(clr2)
					end
				end
			end
		end
		
		

		if(Mode=='The Big Black')then
			local pos = Head.Position
			local dist = (camera.CFrame.p-pos).magnitude
			local DropDist = 1
			local IneffectiveDist = 15
			local modifier = dist < DropDist and 1 or dist < IneffectiveDist and (0 - 1) / (IneffectiveDist - DropDist) * (dist - DropDist) + 1 or 0
		end

		if(State == 'Idle')then
			if(Mode=='BANISHED')then
				local Alpha = .1
				
				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/50),3+0.2*M.C(Sine/25),0+1*M.S(Sine/32))*CF.A(M.R(30+5*M.S(Sine/50)),0+0.1*M.S(Sine/50),0+0.1*M.S(Sine/50)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,-0.9+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.2+.2*M.S(Sine/32),0)*CF.A(-0.6,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.3-.2*M.C(Sine/32),-0.4)*CF.A(-0.8,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.2*M.C(Sine/32),-0.5)*CF.A(-0.7,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				                            elseif(Mode=='SUS')then
                local Alpha = .1
                if(NeutralAnims)then    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.4+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(1,0+.05*M.S(Sine/32),1)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-0-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-1,0+.05*M.S(Sine/32),1)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(0+0*M.C(Sine/32))),Alpha)
                end
                if(legAnims)then 
                    if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(30),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(-30),0.1),Alpha)
                    else
                        LH.C0 = LH.C0:lerp(LHC0,Alpha)
                        RH.C0 = RH.C0:lerp(RHC0,Alpha)
                    end
                end
                
                				                            elseif(Mode=='T E R M I N A T E D')then
                local Alpha = .1
                if(NeutralAnims)then    
                    
                    								    				    				Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.new'Black'.Color;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10,0.5,10);
					EndSize=Vector3.new(10,0.5,10);
					}
                    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.4+-0.3*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
                end
                if(legAnims)then 
                    if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4+0.3*M.C(Sine/32),-0.4)*CF.A(0,M.R(30),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4+0.3*M.C(Sine/32),-0.4)*CF.A(0,M.R(-30),0.2),Alpha)
                    else
                        LH.C0 = LH.C0:lerp(LHC0,Alpha)
                        RH.C0 = RH.C0:lerp(RHC0,Alpha)
                    end
                end
                
                				                            elseif(Mode=='Solar')then
                local Alpha = .1
                if(NeutralAnims)then  


														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					}
					
																			Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Brick};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1+music.PlaybackLoudness/100,0.5,1+music.PlaybackLoudness/100);
					EndSize=Vector3.new(1+music.PlaybackLoudness/100,0.5,1+music.PlaybackLoudness/100);
					}

                    
                    				    Effect{ -- Sun Core
				    					Lifetime=0.8;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0.9,9,-2)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright yellow'.Color;
					Transparency={0.9,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.3,0.6);
					EndSize=Vector3.new(15,0.5,15);
				}
				
		    														Effect{ -- Sun Itself
				Lifetime=0.01;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(255, 255, 0),
				    CFrame=Torso.CFrame*CF.N(0.9,9,-2)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10,10,10);
					EndSize=Vector3.new(10,10,10);
					}
					
							    														Effect{ --Mercury
				Lifetime=0.01;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(100, 100, 100),
				    CFrame=Torso.CFrame*CF.N(0.9,9,-15)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0,1};
					Material=Enum.Material.Slate;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1,1,1);
					}			
					
				Effect{ --EMoon
				Lifetime=0.01;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(100, 100, 100),
				    CFrame=Torso.CFrame*CF.N(-25.2,9,23)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0,1};
					Material=Enum.Material.Slate;
					Size=Vector3.new(0.8,0.8,0.8);
					EndSize=Vector3.new(0.8,0.8,0.8);
					}			
					Effect{ --Venus
				Lifetime=0.01;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(200, 150, 100),
				    CFrame=Torso.CFrame*CF.N(20.9,9,-10)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0,1};
					Material=Enum.Material.Sand;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(2,2,2);
					}
					
										Effect{ --Earth
				Lifetime=0.01;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(50, 50, 255),
				    CFrame=Torso.CFrame*CF.N(-20.9,9,23)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0,1};
					Material=Enum.Material.Sand;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(2,2,2);
					}
					
												Effect{ ---Mars
				Lifetime=0.01;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(255, 100, 100),
				    CFrame=Torso.CFrame*CF.N(-20.9,9,-40)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0,1};
					Material=Enum.Material.Slate;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1,1,1);
					}
																	Effect{ ---Jupiter
				Lifetime=0.01;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(200, 150, 100),
				    CFrame=Torso.CFrame*CF.N(45.9,9,-50)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0,1};
					Material=Enum.Material.Sand;
					Size=Vector3.new(4,4,4);
					EndSize=Vector3.new(4,4,4);
					}
					
																						Effect{ --Saturn
				Lifetime=0.01;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(200, 150, 100),
				    CFrame=Torso.CFrame*CF.N(-70,9,20)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0,1};
					Material=Enum.Material.Sand;
					Size=Vector3.new(3.5,3.5,3.5);
					EndSize=Vector3.new(3.5,3.5,3.5);
					}
															Effect{ -- --Uranus
				Lifetime=0.01;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(100, 100, 255),
				    CFrame=Torso.CFrame*CF.N(-40,9,-80)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0,1};
					Material=Enum.Material.Sand;
					Size=Vector3.new(2.5,2.5,2.5);
					EndSize=Vector3.new(2.5,2.5,2.5);
					}
					
								Effect{ --Neptune
				Lifetime=0.01;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(0, 0, 255),
				    CFrame=Torso.CFrame*CF.N(100.9,9,10)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0,1};
					Material=Enum.Material.Sand;
					Size=Vector3.new(2.5,2.5,2.5);
					EndSize=Vector3.new(2.5,2.5,2.5);
					}
					
																												Effect{
				Lifetime=0.01;
					Mesh='Ring';
					Color=Color3.fromRGB(100, 100, 100),
					CFrame = Torso.CFrame* CF.N(0.9,9,-2) * CF.A(29.8,M.R(math.random(-0,0)),0),
					Transparency={0.8,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(6.5,6.5,0.5);
					EndSize=Vector3.new(6.5,6.5,0.5);
					}
					
																																	Effect{
				Lifetime=0.01;
					Mesh='Ring';
					Color=Color3.fromRGB(200, 150, 0),
					CFrame = Torso.CFrame* CF.N(-70,9,20) * CF.A(29.8,M.R(math.random(-0,0)),0),
					Transparency={0.8,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.5,0.5,0.1);
					EndSize=Vector3.new(0.5,0.5,0.1);
					}
					
				Effect{ -- Moon Ring
				Lifetime=0.01;
					Mesh='Ring';
					Color=Color3.fromRGB(100, 100, 100),
					CFrame = Torso.CFrame* CF.N(-20.9,9,23) * CF.A(29.8,M.R(math.random(-0,0)),0),
					Transparency={0.8,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.5,0.5,0.1);
					EndSize=Vector3.new(0.5,0.5,0.1);
					}	
					
					Effect{
				Lifetime=0.01;
					Mesh='Ring';
					Color=Color3.fromRGB(100, 100, 255),
					CFrame = Torso.CFrame* CF.N(-40,9,-80) * CF.A(0,M.R(math.random(-0,0)),30),
					Transparency={0.8,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.5,0.5,0.1);
					EndSize=Vector3.new(0.5,0.5,0.1);
					}
				
									    
				    				Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,50,0),
Size = Vector3.new(0.5,0.5,0.5),
EndSize = Vector3.new(0.5,0.5,0.5),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
																		    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,50,0),
Size = Vector3.new(0.5,0.5,0.5),
EndSize = Vector3.new(0.5,0.5,0.5),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
																		    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,50,0),
Size = Vector3.new(0.5,0.5,0.5),
EndSize = Vector3.new(0.5,0.5,0.5),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
                    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-140-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(140+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='Destiny')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='ETERNAL')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    
				    				Effect({
Color = Color3.fromRGB(255, 255, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(10+5*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.3,M.R(5+5*M.C(Sine/32)),M.R(15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(150+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='depleted')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    
				    				Effect({
Color = Color3.fromRGB(170, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Maroon'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-20+5*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.4,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.1,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Extinction')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash2",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.8, 0.01, 0.8),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
			    	RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+3.5*M.C(Sine/50),4+1*M.C(Sine/25),0+0*M.S(Sine/32))*CF.A(M.R(50+5*M.S(Sine/50)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.2+.2*M.S(Sine/50),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,-0.3+.2*M.S(Sine/40),-0.7)*CF.A(0,M.R(40-5*M.C(Sine/32)),M.R(-180+20*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Plasmic')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-40+5*M.S(Sine/64)),M.R(5),0.1),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(2.3,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/20))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1,M.R(5-5*M.C(Sine/32)),M.R(15+20*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.0*M.C(Sine/32),0)*CF.A(M.R(27),0.3,M.R(-10)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.0*M.C(Sine/32),0)*CF.A(M.R(27),-0.3,M.R(10)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='TORTURED')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Dark grey'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,5,0),
Size = Vector3.new(0.3,0.3,0.3),
EndSize = Vector3.new(0.3,0.3,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 2,
})
				    
				    				    				Effect({
Color = Color3.fromRGB(100, 100, 100),
Material = Enum.Material.Neon,
Mesh = "Tornado2",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(30, 5, 30),
Transparency = NumberRange.new(0,1),
Lifetime = 0.3,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+10*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
								LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0.1+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-84+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Untrustworthy')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,5,0),
Size = Vector3.new(0.3,0.3,0.3),
EndSize = Vector3.new(0.3,0.3,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 2,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-10,10),-4,(math.random(-10,10))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Maroon'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,7,0),
Size = Vector3.new(0.5,0,0.5),
EndSize = Vector3.new(0.3,10,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

					GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.1,1,.1);
					EndSize=Vector3.new(.5,5,.5);
					}
					
										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.1,1,.1);
					EndSize=Vector3.new(.5,5,.5);
					}

				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(10+5*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-20-10*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(20+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.1*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.1*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Ringed')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    
				    			    
				    				
																	    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh='Ring';
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(0.3,0.3,0.3),
EndSize = Vector3.new(0.3,0.3,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})

				    				Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(30),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.9)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Cuboid')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				
																	    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(1,1,1),
EndSize = Vector3.new(1,1,1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})

				    				Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='disfigured')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    
				    				Effect({
Color = Color3.fromRGB(100, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-30+10*M.S(Sine/1)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.9+.1*M.S(Sine/32),-0.8)*CF.A(2,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.8+.1*M.S(Sine/32),-0.8)*CF.A(1,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.8-.05*M.C(Sine/32),-1)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='ERADICATE')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+10*M.S(Sine/1)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.05*M.S(Sine/32),-0.5)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.05*M.S(Sine/32),-0.5)*CF.A(1,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Multiversal')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    			    
				    				    				Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-20+10*M.S(Sine/32)),M.R(30),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.4,M.R(5+5*M.C(Sine/32)),M.R(-30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.3,0+.05*M.S(Sine/32),-0.5)*CF.A(0,M.R(30-5*M.C(Sine/32)),M.R(-180+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Onslaught')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-40),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.4,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-2.4,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.4)*CF.A(0,M.R(-20),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='TEST')then
				local Alpha = .1
				if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.2+.25*M.C(Sine/0.5),0)*CF.A(M.R(-45+1*M.S(Sine/64)),M.R(0),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.95,0.,M.R(-5.5)),Alpha)
					RH.C0 = RH.C0:lerp(LHC0*CF.N(1,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.95,0.,M.R(-5.5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='ARSONIST')then
				local Alpha = .1
				if(NeutralAnims)then	
			    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright orange'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.4)*CF.A(0,M.R(-20),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='Final Hope')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-40),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,-.2+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(170+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.4)*CF.A(0,M.R(-20),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='DREAM')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(80+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
			    	LS.C0 = LS.C0:lerp(RSC0*CF.N(-3,0+.05*M.S(Sine/25),0)*CF.A(1.4+.8*M.C(Sine/16),M.R(-5-5*M.C(Sine/32)),M.R(-10+-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0+.05*M.S(Sine/32),-0.6)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(210+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Unresponsive')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(30+5*M.S(Sine/64)),M.R(5),-0.4),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-225-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(-0.2,0.7-.05*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),0.4),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='besmirch')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				Effect({
Color = Color3.fromRGB(217, 147, 72),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-20+10*M.S(Sine/60)),M.R(5),0.2),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(-30-10*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1,M.R(5-5*M.C(Sine/32)),M.R(30+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='A n g e l')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    
				    				Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.3,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,15,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(0+30*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.3,.3,-0.5)*CF.A(M.R(30.5+3.5*M.S(Sine/24)),M.R(15),M.R(2)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.5)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(2)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			
		
			elseif(Mode=='M A N I C')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    
				    				    
				    				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-100,100),-4,(math.random(-100,100))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,100,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(4, 0.01, 4),
Transparency = NumberRange.new(0,1),
Lifetime = 0.9,
})
				    
				    
									RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.2+5.4*M.C(Sine/39),30+7.5*M.C(Sine/32),0)*CF.A(M.R(25+5*M.S(Sine/15)),M.R(-5+5*M.C(Sine/15)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(25-2.5*M.S(Sine/64)),M.R(25),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(-0.5,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(10+10*M.C(Sine/32)),M.R(-120-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0.5,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(10-10*M.C(Sine/32)),M.R(25+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.1,0-.05*M.C(Sine/32),0)*CF.A(1.5,M.R(20),-0.0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.1,0.0-.05*M.C(Sine/32),-0.0)*CF.A(1.3,M.R(-10),0.0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='corrupted')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0+music.PlaybackLoudness/100,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0-music.PlaybackLoudness/100,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0-music.PlaybackLoudness/100) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0+music.PlaybackLoudness/100) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})


--2nd Layer Break--
				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0+music.PlaybackLoudness/100,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0-music.PlaybackLoudness/100,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0-music.PlaybackLoudness/100) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0+music.PlaybackLoudness/100) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})


				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

					
										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.1,1,.1);
					EndSize=Vector3.new(.5,5,.5);
					}
					
															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.1,1,.1);
					EndSize=Vector3.new(.5,5,.5);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/40),0)*CF.A(M.R(-10+10*M.S(Sine/40)),M.R(5),0.2),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-30-10*M.C(Sine/40))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,-0.3+.2*M.S(Sine/40),-0.7)*CF.A(0,M.R(40-5*M.C(Sine/32)),M.R(-180+20*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.2,0-.1*M.C(Sine/35),0)*CF.A(-0.5,M.R(-5),1.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5+.1*M.C(Sine/35),-0.7)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				
									elseif(Mode=='A b a N d O e D')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(0+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
	    			LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
										
										
										
										
										
				
											elseif(Mode=='INFINITY GAUNTLET')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0*M.C(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='LOST')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.1+0.05*M.C(Sine/64),0)*CF.A(M.R(-30+0.2*M.S(Sine/64)),M.R(0),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.8,-0.0+.1*M.S(Sine/32),-1)*CF.A(0.2,M.R(80-0*M.C(Sine/32)),M.R(210+20*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-1.1,-0.0+.1*M.S(Sine/32),-1)*CF.A(0.2,M.R(80-0*M.C(Sine/32)),M.R(210+20*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/64),0)*CF.A(M.R(30+0.2*M.S(Sine/64)),M.R(-0),-0.0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/64),0)*CF.A(M.R(30+0.2*M.S(Sine/64)),M.R(-0),0.0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Forgotten')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(-10+0*M.S(Sine/64)),M.R(5),-0.1+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+0.08*M.S(Sine/32),-0.7)*CF.A(1.4,M.R(0+0*M.C(Sine/32)),M.R(90-0*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.8,0.2+0.08*M.S(Sine/32),-0.9)*CF.A(1.4,M.R(0-0*M.C(Sine/32)),M.R(-95+0*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.1)*CF.A(0.2,M.R(20),-0.07),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),-0.3)*CF.A(0.2,M.R(-25),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='CHOICE')then
				local Alpha = .1
				
													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Wedge};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Tr. Red'.Color;
					Transparency={.5,1};
					Material=Enum.Material.CorrodedMetal;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then
			
			 local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Tr. Red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
			
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(0,M.R(0+0*M.C(Sine/32)),M.R(-20-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(0,M.R(0-0*M.C(Sine/32)),M.R(150+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(0-3*M.S(Sine/32)),M.R(5),-0.0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(0-3*M.S(Sine/32)),M.R(-5),0.0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='CORROSION')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Tr. Red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.S(Sine/32),0)*CF.A(0.1,M.R(0+0*M.C(Sine/32)),M.R(-10-2*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0.0,0.2+.1*M.S(Sine/32),0)*CF.A(0,M.R(0-0*M.C(Sine/32)),M.R(210+2*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.1)*CF.A(M.R(0-1*M.S(Sine/32)),M.R(15),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),-0.2)*CF.A(M.R(0-1*M.S(Sine/32)),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				

							elseif(Mode=='サイコ')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Tr. Red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(-20-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(0-3*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),-0.0+0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(0-3*M.S(Sine/32)),M.R(-5+0*M.C(Sine/32)),0.0+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

                			elseif(Mode=='Pyro')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Tr. Red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1+0.2*M.C(Sine/32),0)*CF.A(M.R(-45+5*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(35-2.5*M.S(Sine/32)),M.R(-5),0.5),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(85+5*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(-45+15*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(85+5*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(45-15*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1.3-.2*M.C(Sine/32),-1)*CF.A(M.R(45-5*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),-0.0+0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.1-.2*M.C(Sine/32),-0.1)*CF.A(M.R(-15-5*M.S(Sine/32)),M.R(-5+0*M.C(Sine/32)),0.0+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

                
				
							elseif(Mode=='Expitition')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Wedge};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Dark blue'.Color;
					Transparency={.5,1};
					Material=Enum.Material.CorrodedMetal;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Dark blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,12+3*M.C(Sine/32),0)*CF.A(M.R(0-20*M.S(Sine/32)),M.R(5),0.2+0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10+10*M.S(Sine/32)),M.R(-45-10*M.S(Sine/32)),0.2),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,-0.1+0.1*M.S(Sine/32),0.2)*CF.A(-0.7+0.2*M.S(Sine/32),M.R(6+2*M.C(Sine/32)),M.R(45-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.2+.3*M.S(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(145+15*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6-.0*M.C(Sine/32),-0.6)*CF.A(M.R(0-10*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),0.1+0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.0*M.C(Sine/32),0)*CF.A(M.R(0-0*M.S(Sine/32)),M.R(-5+0*M.C(Sine/32)),0.4+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='GLITCHED')then WingAnims.archsword=function()
		LWP1W.C0 = LWP2W.C0:lerp(CF.N(-3+3*M.C(WingSine/32),3,-1)*CF.A(M.R(-25+5*M.C(WingSine/32)+0*M.C(WingSine/32)),0,M.R(-90+-50*(WingSine/64))),1) -- DemonGodSword
		LWP2W.C0 = LWP2W.C0:lerp(CF.N(-3+3*M.C(WingSine/32),9,-1)*CF.A(M.R(-25+5*M.C(WingSine/32)+0*M.C(WingSine/32)),0,M.R(-180+-50*(WingSine/64))),1) -- RainbowGodSword
		LWP3W.C0 = LWP3W.C0:lerp(CF.N(-3+3*M.C(WingSine/32),3,-1)*CF.A(M.R(-25+5*M.C(WingSine/32)),0,M.R(-180+-50*(WingSine/64))),1) -- DemonLordSword

		RWP1W.C0 = RWP2W.C0:lerp(CF.N(-6+3*M.C(WingSine/32),3,-1)*CF.A(M.R(-25+5*M.C(WingSine/32)),0,M.R(90+-50*(WingSine/64))),1) -- AuroraSword
		RWP2W.C0 = RWP2W.C0:lerp(CF.N(-3+3*M.C(WingSine/32),9,-1)*CF.A(M.R(-25+5*M.C(WingSine/32)),0,M.R(0+-50*(WingSine/64))),1) -- VoidLordSword
		RWP3W.C0 = RWP3W.C0:lerp(CF.N(-3+3*M.C(WingSine/32),3,-1)*CF.A(M.R(-25+5*M.C(WingSine/32)),0,M.R(0+-50*(WingSine/64))),1) -- CorruptLordSword
		--SPIN
		RWP4W.C0 = RWP4W.C0:lerp(CF.N(0*M.C(WingSine/62),-1.64+0*M.S(WingSine/42),-1.2)*CF.A(0,0,M.R(-0-950*M.C(WingSine/400))),.2)
	RWP5W.C0 = RWP5W.C0:lerp(CF.N(0*M.C(WingSine/62),0-0*M.S(WingSine/42),-2)*CF.A(0,0,M.R(-0+950*M.C(WingSine/200))),.2)
	end
				local Alpha = .1
				if(NeutralAnims)then

                    
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Tr. Red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.0+0.1*M.C(Sine/32),0)*CF.A(M.R(-0+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-15-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.2+.08*M.S(Sine/32),0)*CF.A(M.R(-2+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(-20-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0.3+.08*M.S(Sine/32),-0.8)*CF.A(M.R(90+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(-80+5*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.0-.1*M.C(Sine/32),0)*CF.A(M.R(-0-3*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),-0.0+0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.0-.1*M.C(Sine/32),-0.0)*CF.A(M.R(0-3*M.S(Sine/32)),M.R(-5+0*M.C(Sine/32)),0.0+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
			
				
				elseif(Mode=='Eradicating')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.5+0.1*M.C(Sine/32),0)*CF.A(M.R(-20+3*M.S(Sine/32)),M.R(5),0.1+0.0*M.C(Sine/32)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-20-3.5*M.S(Sine/32)),M.R(20),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(15+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.4,0+.0*M.S(Sine/32),-0.65)*CF.A(M.R(75+0*M.S(Sine/32)),M.R(0-5*M.C(Sine/32)),M.R(-95+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.8-.1*M.C(Sine/32),-0.8)*CF.A(M.R(20-3*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),-0.1-0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-0.1-.1*M.C(Sine/32),0)*CF.A(M.R(-35-3*M.S(Sine/32)),M.R(-5+0*M.C(Sine/32)),0.2-0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='SANCTUARY')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Tr. Red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,15+5*M.C(Sine/32),0)*CF.A(M.R(-85+20*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(50-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(-35+0*M.C(Sine/32)),M.R(-160-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(0+45*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.3,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(0.3+0.2*M.S(Sine/32),M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
					elseif(Mode=='REDEMPTION')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Tr. Red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1+0.05*M.C(Sine/32),0)*CF.A(M.R(-40+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-25-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(-25-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-1.4,0+.08*M.S(Sine/32),-0.8)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(-60+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1-.05*M.C(Sine/32),-1)*CF.A(M.R(40-3*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),-0.0+0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-1.2)*CF.A(M.R(-20-3*M.S(Sine/32)),M.R(-5+0*M.C(Sine/32)),0.0+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
					elseif(Mode=='VIRTUE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.2*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-5-3.5*M.S(Sine/32)),M.R(25),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(-45+10*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-1,-0.8+.08*M.S(Sine/32),-0.7)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(195+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.2-.2*M.C(Sine/32),0)*CF.A(M.R(20-4*M.S(Sine/32)),M.R(40+0*M.C(Sine/32)),-0.1+0.0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-0.2-.2*M.C(Sine/32),0)*CF.A(M.R(-10-3*M.S(Sine/32)),M.R(-15+0*M.C(Sine/32)),0.3+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='Damaged')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Wedge};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Tr. Red'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
					
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Tr. Red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.2*M.C(Sine/24),0)*CF.A(M.R(2+5*M.C(Sine/24)),M.R(5),0.0+0.05*M.C(Sine/24)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(30-2.5*M.S(Sine/24)),M.R(45),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/24),0)*CF.A(M.R(0+0*M.S(Sine/24)),M.R(-0+0*M.C(Sine/24)),M.R(-175+10*M.C(Sine/24))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.0+.2*M.S(Sine/24),0)*CF.A(M.R(-3+1*M.S(Sine/24)),M.R(-25-0*M.C(Sine/24)),M.R(10+10*M.C(Sine/24))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.1-.2*M.C(Sine/24),-0.2)*CF.A(M.R(4-5*M.C(Sine/24)),M.R(30+2*M.C(Sine/24)),-0.0-0.05*M.C(Sine/24)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-0.1-.2*M.C(Sine/24),0)*CF.A(M.R(-15-5*M.C(Sine/24)),M.R(-5+0*M.C(Sine/24)),0.1-0.05*M.C(Sine/24)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
					elseif(Mode=='F A L L E N')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Tr. Red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,20+1*M.C(Sine/64),0)*CF.A(M.R(70+10*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.0,0.2+.05*M.S(Sine/32),0.3)*CF.A(-0.4+0.4*M.C(Sine/64),M.R(5+5*M.C(Sine/32)),M.R(-14-0*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.0,0.2+.05*M.S(Sine/32),0.3)*CF.A(-0.4+0.0*M.C(Sine/64),M.R(5-5*M.C(Sine/32)),M.R(7+0*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.4)*CF.A(-0.6-0.2*M.C(Sine/32),M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.3-.05*M.C(Sine/32),-0.4)*CF.A(-0.5-0.2*M.C(Sine/32),M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='C O M P L E X')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				        							    GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright blue'.Color;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,15,0.2);
				}
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,24+5*M.C(Sine/32),0)*CF.A(M.R(-20+8*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.4,0+.08*M.S(Sine/32),-0.4)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(25+0*M.C(Sine/32)),M.R(-220-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,-0.4+.08*M.S(Sine/32),-0.8)*CF.A(M.R(85+10*M.S(Sine/32)),M.R(-0-0*M.C(Sine/32)),M.R(-90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.0*M.C(Sine/32),-0.6)*CF.A(M.R(-20-10*M.S(Sine/38)),M.R(0+0*M.C(Sine/28)),-0.0+0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.0*M.C(Sine/32),0)*CF.A(M.R(-25-10*M.S(Sine/38)),M.R(-0+0*M.C(Sine/28)),0.05+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='V E L D U S')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    									GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
				    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				    
				  				    				Effect({
Color = Color3.fromRGB(255, 0, 40),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,20,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,20,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})  
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2.0*M.C(Sine/32),0)*CF.A(M.R(-45+8*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,0.6+.1*M.S(Sine/32),-0.4)*CF.A(3.1,M.R(-20-2*M.C(Sine/30)),M.R(40+1*M.C(Sine/5))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.1+.08*M.S(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(45+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.0*M.C(Sine/32),-0.6)*CF.A(M.R(-20-10*M.S(Sine/38)),M.R(0+0*M.C(Sine/28)),-0.0+0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.0*M.C(Sine/32),0)*CF.A(M.R(-25-10*M.S(Sine/38)),M.R(-0+0*M.C(Sine/28)),0.05+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='LEXUS ERR0R')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Tr. Red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,6+3*M.C(Sine/32),0)*CF.A(M.R(10+5*M.S(Sine/32)),M.R(5),0.0+-0.1*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,-0.6+.2*M.S(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),M.R(-145-10*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,-0.6+.2*M.S(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(-5-0*M.C(Sine/32)),M.R(145+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.0*M.C(Sine/32),-0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.0*M.C(Sine/32),-1)*CF.A(-0.8+0.2*M.S(Sine/32),M.R(-5),0.2+0.1*M.S(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='CORRODE')then
				local Alpha = .1
				if(NeutralAnims)then		    								    																		    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright violet'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-2+0.0*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.4,0+.0*M.S(Sine/32),-0.7)*CF.A(M.R(95+1*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(75-2*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.3+.1*M.S(Sine/32),0)*CF.A(M.R(-25+3*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(20+2*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1-.0*M.C(Sine/32),-0.6)*CF.A(M.R(65-1*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),-0.0+0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.0*M.C(Sine/32),-0.5)*CF.A(M.R(90-1*M.S(Sine/32)),M.R(-5+0*M.C(Sine/32)),0.0+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
							elseif(Mode=='NEAR DEATH')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright violet'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.8+0.0*M.C(Sine/32),0)*CF.A(M.R(-90+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0-0.0*M.S(Sine/32),-0.2-0.1*M.S(Sine/32))*CF.A(M.R(100+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(-0-0*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0+.0*M.S(Sine/32),-0.7)*CF.A(M.R(150+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(-90+0*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.0*M.C(Sine/32),-0.7)*CF.A(M.R(5-3*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),-0.1+0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-0.3-.0*M.C(Sine/32),0)*CF.A(M.R(30-3*M.S(Sine/32)),M.R(-0+0*M.C(Sine/32)),0.1+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
					elseif(Mode=='EARTHQUAKE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1+0.05*M.C(Sine/32),0)*CF.A(M.R(-40+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(15-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(- 40+0*M.S(Sine/32)),M.R(15+0*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.9+.08*M.S(Sine/32),-0.3)*CF.A(M.R(40+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(20+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1-.05*M.C(Sine/32),-1)*CF.A(M.R(40-3*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),-0.0+0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-1.2)*CF.A(M.R(-20-3*M.S(Sine/32)),M.R(-5+0*M.C(Sine/32)),0.0+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
	
				
							elseif(Mode=='CRAZED')then
				local Alpha = .1
				if(NeutralAnims)then	
			
			 local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
			
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+2.5*M.C(Sine/32),0)*CF.A(M.R(30+3*M.S(Sine/32)),M.R(5),0.05+-0.02*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0.6+.08*M.S(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(-165-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.9,-0.0+.1*M.S(Sine/32),-1)*CF.A(0.2,M.R(80-0*M.C(Sine/32)),M.R(210+20*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.0*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.0*M.C(Sine/32),-1)*CF.A(-0.8+0.2*M.S(Sine/32),M.R(-5),0.2+0.1*M.S(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='CONTROLLED')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright violet'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,6+1*M.C(Sine/32),0)*CF.A(M.R(20+3*M.S(Sine/32)),M.R(5),0.0+-0.05*M.C(Sine/32)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.08*M.S(Sine/32),-0.7)*CF.A(M.R(75+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(85-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.4,-0.3+.08*M.S(Sine/32),-0.9)*CF.A(M.R(-75+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(-85+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.0*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.0*M.C(Sine/32),-1)*CF.A(-0.8+0.2*M.S(Sine/32),M.R(-5),0.2+0.1*M.S(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='DARK')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.8,0+.08*M.S(Sine/32),-0.7)*CF.A(M.R(75+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(85-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0.2+.08*M.S(Sine/32),-0.6)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(210+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.1)*CF.A(M.R(0-3*M.S(Sine/32)),M.R(15),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),-0.2)*CF.A(M.R(0-3*M.S(Sine/32)),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='XENOPHERIC')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Light orange brown'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})

				    								    																		   
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+2.5*M.C(Sine/32),0)*CF.A(M.R(0+2.5*M.S(Sine/32)),M.R(5),0.05+-0.02*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.1*M.S(Sine/32),0)*CF.A(M.R(-20+8*M.S(Sine/32)),M.R(0+5*M.C(Sine/32)),M.R(-35-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.9,-0.0+.1*M.S(Sine/32),-1)*CF.A(0.2,M.R(80-0*M.C(Sine/32)),M.R(210+20*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.0*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.0*M.C(Sine/32),-1)*CF.A(-0.8+0.0*M.S(Sine/32),M.R(-5),0.2+0.1*M.S(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='P A I N')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
}) 
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1+0.05*M.C(Sine/32),0)*CF.A(M.R(-30+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.08*M.S(Sine/32),-0.7)*CF.A(M.R(75+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(85-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.3+.08*M.S(Sine/32),0)*CF.A(M.R(30+0*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1-.05*M.C(Sine/32),-0.6)*CF.A(M.R(30-3*M.S(Sine/32)),M.R(5+0*M.C(Sine/32)),-0.0+0*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-1.4)*CF.A(M.R(-45-3*M.S(Sine/32)),M.R(-0+0*M.C(Sine/32)),0.2+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='REPRECAUTION')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.0,-0.0+.08*M.S(Sine/32),-0.0)*CF.A(2,M.R(0+0*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.9,-0.0+.08*M.S(Sine/32),-1)*CF.A(0.2,M.R(80-0*M.C(Sine/32)),M.R(210+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.3-.05*M.C(Sine/32),-0.2)*CF.A(M.R(-35-1*M.S(Sine/32)),M.R(5),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),-0.2)*CF.A(M.R(10-1*M.S(Sine/32)),M.R(-25),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='FLAME')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				   local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright violet'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})  
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.2*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5+10*M.S(Sine/32)),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0+0.1*M.S(Sine/32),0.2)*CF.A(-0.7,M.R(6+2*M.C(Sine/32)),M.R(45-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(0,M.R(0-0*M.C(Sine/32)),M.R(30+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(M.R(-5-3*M.S(Sine/32)),M.R(5),-0.0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(M.R(0-3*M.S(Sine/32)),M.R(-5),0.0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='PSYCHIC')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.1*M.C(Sine/32),0)*CF.A(M.R(0+4*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0.2),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.7,-0.0+.1*M.S(Sine/32),-0.6)*CF.A(1.5,M.R(0+0*M.C(Sine/32)),M.R(90+.2*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,0+.08*M.S(Sine/32),0.7)*CF.A(M.R(1.2+0.2*M.S(Sine/32)),M.R(0-0*M.C(Sine/32)),M.R(-45+1*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.1*M.C(Sine/32),0)*CF.A(M.R(0-4*M.S(Sine/32)),M.R(20),-0.0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.1*M.C(Sine/32),0)*CF.A(M.R(0-4*M.S(Sine/32)),M.R(-10),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='COLLAPSED')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0+5*M.S(Sine/32),12+5*M.C(Sine/32),0)*CF.A(M.R(10+0*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.7,-0.7+.1*M.S(Sine/32),-0.6)*CF.A(2,M.R(2+0*M.C(Sine/32)),M.R(65+.2*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,0+0.3*M.S(Sine/32),0.2)*CF.A(-0.7,M.R(0-0*M.C(Sine/32)),M.R(-45-10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.8,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='EMPERATOR')then
					
						local Alpha = .1	
					if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(10+5*M.S(Sine/32),10+5*M.C(Sine/64),0)*CF.A(M.R(60+10*M.S(Sine/32)),M.R(-0+0*M.C(Sine/100)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-65-20*M.S(Sine/32)),M.R(25),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,-0.1+.05*M.S(Sine/32),0)*CF.A(-1.3,M.R(-20+0*M.C(Sine/32)),M.R(-130-10*M.C(Sine/30))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,-0.1+.05*M.S(Sine/32),0)*CF.A(-1.3,M.R(20-0*M.C(Sine/32)),M.R(130+10*M.C(Sine/30))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
							LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.3-.0*M.C(Sine/32),-0.6)*CF.A(0.0+0.0*M.S(Sine/64),M.R(10),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.0*M.C(Sine/32),-0.7)*CF.A(-0.6+0.0*M.S(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='ERR0R')then
				local Alpha = .1
				if(NeutralAnims)then
				        
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				    
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,20+3*M.C(Sine/32),0)*CF.A(M.R(30+3*M.S(Sine/1)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0.6+.1*M.S(Sine/32),-0.3)*CF.A(0,M.R(10-2*M.C(Sine/30)),M.R(-230+30*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.2+.2*M.S(Sine/32),0)*CF.A(-0.6,M.R(5-5*M.C(Sine/math.random(1,15))),M.R(60+30*M.C(Sine/math.random(1,15)))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.8+0.2*M.S(Sine/32),M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='WARP')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				     local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				    
				  				    				Effect({
Color = Color3.fromRGB(255, 0, 40),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,20,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,20,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})  
				    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/32)),M.R(5),0.0+-0.0*M.C(Sine/28)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,0+.08*M.S(Sine/32),-0.6)*CF.A(1.3,M.R(0+0*M.C(Sine/32)),M.R(75-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,0+.08*M.S(Sine/32),-0.8)*CF.A(1.3,M.R(0-0*M.C(Sine/32)),M.R(-65+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.0-.05*M.C(Sine/32),0)*CF.A(M.R(0-3*M.S(Sine/32)),M.R(5),-0.0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-0.0-.05*M.C(Sine/32),0)*CF.A(M.R(-0-3*M.S(Sine/32)),M.R(-5),0.0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				------------continuing-----------------------------
				
							elseif(Mode=='HOPELESS')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/20),0)*CF.A(M.R(-10+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-100*M.S(Sine/1)),M.R(-5+100*M.S(Sine/1)),0+100*M.S(Sine/1)),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.5,M.R(5+5*M.C(Sine/32)),M.R(-5-10*M.C(Sine/1))),Alpha)
 					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0+.05*M.S(Sine/32),-0.6)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(210+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.3,0-.1*M.C(Sine/35),0)*CF.A(-0.5,M.R(-5),1.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5+.1*M.C(Sine/35),-0.7)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='decaying soul')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    
				    				    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Brown'.Color;
Material = Enum.Material.DiamondPlate,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,20,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    				    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Brown'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,20,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.4,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(30+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
			    	LS.C0 = LS.C0:lerp(RSC0*CF.N(-3,0+.05*M.S(Sine/25),0)*CF.A(1.4+.8*M.C(Sine/16),M.R(-5-5*M.C(Sine/32)),M.R(-10+-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0+.05*M.S(Sine/32),-0.6)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(210+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
											elseif(Mode=='RADIANT')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				    
				    				    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,20,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,20,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    				    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,20,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash2",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.8, 0.01, 0.8),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
				    
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,6+2*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(-30),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.9,M.R(5+5*M.C(Sine/32)),M.R(-20-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),0.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),-0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='MONSTROSITY')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-225-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='INCOMPREHENSIBLE')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,20,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = Color3.fromRGB(255, 0, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.6, 0.01, 0.6),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-30+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(30-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-30+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-1.1,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-1.1,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='FORMALITY')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.2*M.C(Sine/20),0)*CF.A(M.R(30+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-100*M.S(Sine/1)),M.R(-5+100*M.S(Sine/1)),0+100*M.S(Sine/1)),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.2+.2*M.S(Sine/32),0)*CF.A(-0.6,M.R(5+5*M.C(Sine/math.random(1,15))),M.R(-15-30*M.C(Sine/math.random(1,15)))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.2+.2*M.S(Sine/32),0)*CF.A(-0.6,M.R(5-5*M.C(Sine/math.random(1,15))),M.R(15+30*M.C(Sine/math.random(1,15)))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/20),0.7)*CF.A(-1,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-0.3-.2*M.C(Sine/20),-0.2)*CF.A(-0.4,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='PRISM')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Pneumonoultramicroscopicsilicovolcanoconiosis')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/50),0)*CF.A(M.R(20+10*M.S(Sine/50)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.1*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.1*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
						
						
					end
				end
				
			elseif(Mode=='INSANITY')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.random().Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,4,0.1),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.4+.05*M.C(Sine/32),0)*CF.A(M.R(-20+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(30-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-30+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-65),-0.2,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.4-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(7),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='HOLOGRAPHIC')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    							    			    				GotEffect{
					Lifetime=.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame=Torso.CFrame*CF.N(0,1.5,-5)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Color=BrickColor.new'Cyan'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(10,10,0.5);
				}
				
				Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    				    
				    				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
					
										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright blue'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
				    
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+0*M.C(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
		    		LS.C0 = LS.C0:lerp(LSC0*CF.N(.4,-.2+.05*M.S(Sine/32),.3)*CF.A(M.R(-30),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.8,M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.3)*CF.A(0,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.3)*CF.A(0,M.R(-20),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='POWER')then
										    
										    
										    
				local Alpha = .1
				if(NeutralAnims)then
				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
				    							    
					GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright yellow'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}

					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.8,M.R(5+5*M.C(Sine/32)),M.R(-30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.8,M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='THE TRUE ENDING')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0.5+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-220-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='UNDONE')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.3,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='G A M I N G C H A I R')then
				local Alpha = .1
				if(NeutralAnims)then
				    
local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(10+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(100-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.3+.05*M.S(Sine/32),0.2)*CF.A(0.5,M.R(5-0*M.C(Sine/32)),M.R(235+2*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1-.05*M.C(Sine/32),0)*CF.A(1,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(1.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='PULSAR')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/32),0)*CF.A(M.R(10+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-225-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(25-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.4,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Looped Error')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+2*M.C(Sine/32),0)*CF.A(M.R(-40+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.1*M.C(Sine/32),-0.2)*CF.A(0.9,M.R(-5),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.1*M.C(Sine/32),-0)*CF.A(0.9,M.R(-5),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
											elseif(Mode=='APCOCLYPTIC')then
				local Alpha = .1
				
								    													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
																	GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(20+10*M.S(Sine/64)),M.R(5),0.5),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(130+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.4)*CF.A(-0.5,M.R(-5),-0.5),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.4)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
			elseif(Mode=='GENOCIDE')then
				local Alpha = .1
				
																								    												    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})	
		if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.3+0*M.C(Sine/32),0)*CF.A(M.R(-50+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(30-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-30+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.8,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.8,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='PESTILENCE')then
				local Alpha = .1
										     local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(90+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-100-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(100+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.4),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='BURNING BRAIN')then
				local Alpha = .1
														     local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0.5+.5*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-200-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(200+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.6)*CF.A(-0.4,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.0-.05*M.C(Sine/32),-0)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='ACE-OF-SPADES')then
												    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
										    
										    									GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright yellow'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.5,0.5,0.5);
					EndSize=Vector3.new(0,0,4);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.5,0.5,0.5);
					EndSize=Vector3.new(0,0,4);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright yellow'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.5,0.5,0.5);
					EndSize=Vector3.new(0,0,4);
					}
					
					BrickColor.new("")
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.5,0.5,0.5);
					EndSize=Vector3.new(0,0,4);
					}
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,7+.5*M.C(Sine/32),0)*CF.A(M.R(0+5*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-160-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.7,-0.3+.05*M.S(Sine/32),-0.4)*CF.A(20,M.R(-10-5*M.C(Sine/32)),M.R(-90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1-.05*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='DESTRUCTION')then
						     local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(150+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.7)*CF.A(-0.4,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.7,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='???')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(10+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-25-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.1,0+.05*M.S(Sine/32),0)*CF.A(M.R(175),M.R(5-2.5*M.C(Sine/32)),M.R(-25-1.5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.5)*CF.A(-0.6,M.R(-5),-0.05),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.5)*CF.A(-0.4,M.R(-5),0.05),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='TIME WARP')then
				local Alpha = .1
				if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2.05*M.C(Sine/80),0)*CF.A(M.R(-0+10*M.S(Sine/32)),M.R(-0+999*M.C(Sine/80)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-90-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

							elseif(Mode=='Nefarious')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/20),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.3)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.3)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

											elseif(Mode=='Atomic Collisions')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-200-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.7,-0.3+.05*M.S(Sine/32),-0.4)*CF.A(0,M.R(-10-5*M.C(Sine/32)),M.R(-90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.8-.1*M.C(Sine/32),-0.3)*CF.A(-0.3,M.R(20),-0.08),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.1*M.C(Sine/32),-0.3)*CF.A(-0.4,M.R(-20),0.08),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				
											elseif(Mode=='Lightning Cannon')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(0+2*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(2.5,M.R(5+5*M.C(Sine/32)),M.R(-380-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.4,M.R(5-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6-.1*M.C(Sine/32),-0.3)*CF.A(-0.2,M.R(20),-0.08),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.1*M.C(Sine/32),-0.3)*CF.A(-0.3,M.R(-20),0.08),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Ɇ₵ⱧØ')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/1),0)*CF.A(0,M.R(5+20*M.C(Sine/1)),M.R(-20-20*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/10),0)*CF.A(0,M.R(-5),-0.05),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.2*M.C(Sine/10),0)*CF.A(0,M.R(-5),0.05),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='ECHO')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.2*M.C(Sine/10),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+0.4*M.S(Sine/10),0)*CF.A(-0.5,M.R(5+20*M.C(Sine/1)),M.R(-10-20*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+0.4*M.S(Sine/10),0)*CF.A(-0.5,M.R(5-20*M.C(Sine/1)),M.R(10+20*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/10),0)*CF.A(M.R(-18),0,M.R(-1)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.2*M.C(Sine/10),0)*CF.A(M.R(-18),0,M.R(1)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='THE VOID')then
				local Alpha = .1
															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/1)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),7,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0.1+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-84+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,100,M.R(2.5)),Alpha)
					end
				end
				
															elseif(Mode=='DREADED')then
				local Alpha = .1
															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
					
															    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(30+5*M.S(Sine/32)),0.2,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),7,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-1.2)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0.1+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-84+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,100,M.R(2.5)),Alpha)
					end
				end
				
															elseif(Mode=='FORCE')then
				local Alpha = .1
															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/1)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),7,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,100,M.R(2.5)),Alpha)
					end
				end
				
															elseif(Mode=='HYBRID')then
				local Alpha = .1
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/1)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),7,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0.1+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-84+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,100,M.R(2.5)),Alpha)
					end
				end
				
																			elseif(Mode=='Darkness')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,10,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(30+5*M.S(Sine/32)),M.R(9),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-1.2)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0.1+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-84+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.9-.05*M.C(Sine/32),-0.9)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='ACCENTION')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.4,-0.56)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(1,0.3,1);
				}		
				
								    GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,15,0.2);
				}	
				
												    GotEffect{
					Lifetime=0.0001;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={0.8,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(8,8,8);
					EndSize=Vector3.new(8,8,8);
				}	
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0+2*M.S(Sine/20),2+1*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/20)),M.R(0+15*M.S(Sine/20)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.6+.2*M.C(Sine/32),M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.6+0.2*M.C(Sine/32),M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-.1*M.C(Sine/32),-0.7)*CF.A(-0.2+0.3*M.C(Sine/20),M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.1*M.C(Sine/32),0)*CF.A(-0.7+0.3*M.C(Sine/20),M.R(-20),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='SCARRED')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/40,0.5,3+music.PlaybackLoudness/40);
					EndSize=Vector3.new(3+music.PlaybackLoudness/40,0.5,3+music.PlaybackLoudness/40);
					}
				    
				    								    GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame=Head.CFrame*CF.N(0.2,0.3,-0.7)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0.2,0);
					EndSize=Vector3.new(0.2,4,0.2);
				}	
				
				

																			Effect{
				Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					CFrame = Root.CFrame* CF.N(math.random(-20,20),-3,math.random(-20,20)) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,10+music.PlaybackLoudness/100,1);
					EndSize=Vector3.new(1,10+music.PlaybackLoudness/100,1);
					}
				
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/32),0)*CF.A(M.R(30+10*M.S(Sine/32)),M.R(10),0.3),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-180-2.5*M.S(Sine/32)),M.R(-180),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,-0.6+.05*M.S(Sine/32),-0.4)*CF.A(2.4,M.R(5+5*M.C(Sine/32)),M.R(30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(-15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.8)*CF.A(-0.3+0.2*M.C(Sine/32),M.R(-5),0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7+0.2*M.C(Sine/32),M.R(-5),-0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Malfunction')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Camo'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
																							Effect{
				Lifetime=0.5;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-20,20),math.random(-20,20),math.random(-20,20)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(2,2,2);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/32),0)*CF.A(M.R(30+10*M.S(Sine/32)),M.R(-30),0-0.1*M.C(Sine/32)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.2*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.7,M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4+.2*M.C(Sine/32),-0.7)*CF.A(-0.5+0.2*M.C(Sine/32),M.R(-5),0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.7+0.2*M.C(Sine/32),M.R(-5),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='ABNORMALITY')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    							    				    				Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.3,
})

														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					}
					
																			Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Brick};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1+music.PlaybackLoudness/100,0.5,1+music.PlaybackLoudness/100);
					EndSize=Vector3.new(1+music.PlaybackLoudness/100,0.5,1+music.PlaybackLoudness/100);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+1*M.C(Sine/32),0)*CF.A(M.R(50+10*M.S(Sine/32)),M.R(30),0-0.1*M.C(Sine/32)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,-0.6+.05*M.S(Sine/32),-0.4)*CF.A(2.4,M.R(5+5*M.C(Sine/32)),M.R(30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.1*M.S(Sine/32),0)*CF.A(0.7,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.7)*CF.A(-0.5+0.3*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7+0.3*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
								
											elseif(Mode=='DEMENTED')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    																							Effect{
				Lifetime=0.2;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.random().Color;
    				CFrame = Torso.CFrame* CF.N(math.random(-20,20),math.random(-20,20),math.random(-20,20)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(2,2,2);
					}
					
									    																							Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.random().Color;
					CFrame = Root.CFrame* CF.N(0,10,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,0};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2+music.PlaybackLoudness/100,2+music.PlaybackLoudness/100,2+music.PlaybackLoudness/100);
					EndSize=Vector3.new(2+music.PlaybackLoudness/100,2+music.PlaybackLoudness/100,2+music.PlaybackLoudness/100);
					}
					
																																	Effect{
				Lifetime=0.01;
					Mesh='Ring';
                    Color = BrickColor.random().Color;
					CFrame = Root.CFrame* CF.N(0,10,0) * CF.A(29.8,M.R(math.random(-0,0)),0),
					Transparency={0,0};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.1+music.PlaybackLoudness/250,0.1+music.PlaybackLoudness/250,0.1);
					EndSize=Vector3.new(0.1+music.PlaybackLoudness/250,0.1+music.PlaybackLoudness/250,0.1);
					}
				    
RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.7+0*M.C(Sine/39),-0)*CF.A(M.R(20+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/24)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.9,M.R(5+5*M.C(Sine/32)),M.R(20-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.7,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.5)*CF.A(0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(1.2,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
															elseif(Mode=='broom')then
				local Alpha = .1
				if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+3.5*M.C(Sine/50),4+1*M.C(Sine/25),0+2*M.S(Sine/32))*CF.A(M.R(-30+5*M.S(Sine/50)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.4,-1+.05*M.S(Sine/32),-0.7)*CF.A(0.9,M.R(5+5*M.C(Sine/32)),M.R(90-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.4,0+.05*M.S(Sine/32),0.8)*CF.A(0.5,M.R(5-5*M.C(Sine/32)),M.R(-10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.1*M.C(Sine/32),-1.0)*CF.A(-0.2-.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-1.0)*CF.A(-0.6-.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='MEMER')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/32),0+1*M.S(Sine/64))*CF.A(M.R(40+360*M.S(Sine/64)),M.R(0+10*M.S(Sine/32)),0+3*M.S(Sine/64)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.1-0.1+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5+5*M.C(Sine/32)),M.R(-30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.1+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='SCP 3857 - 2')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/32),0)*CF.A(M.R(0+8*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.9,-1.6+.05*M.S(Sine/32),-0.5)*CF.A(1.9,M.R(5+5*M.C(Sine/32)),M.R(15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.9,-1.6+.05*M.S(Sine/32),-0.5)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(-15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0.4,0.2-.05*M.C(Sine/32),-1.6)*CF.A(1.3,M.R(-5),1.0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),-1.6)*CF.A(0.4,M.R(-5),-0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='SCP 3857 - 1')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
Size = Vector3.new(0, 0.01, 3*music.PlaybackLoudness/40),
EndSize = Vector3.new(0-music.PlaybackLoudness/30, 0, 0-music.PlaybackLoudness/30),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
Size = Vector3.new(3*music.PlaybackLoudness/40, 0.01, 0),
EndSize = Vector3.new(0-music.PlaybackLoudness/30, 0, 0-music.PlaybackLoudness/30),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(0+5*M.S(Sine/32)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-100*M.S(Sine/1)),M.R(-5+100*M.S(Sine/1)),0+100*M.S(Sine/1)),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(-0.9+0*M.S(Sine/32),-1.3+.05*M.S(Sine/32),0.2+-0*M.C(Sine/32))*CF.A(0.7+0*M.C(Sine/32),M.R(10+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.3,-0.5+.05*M.S(Sine/32),-1.8)*CF.A(3.2+0.2*M.C(Sine/32),M.R(5-5*M.C(Sine/32)),M.R(-35+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.8,2-.05*M.C(Sine/32),0+0*M.C(Sine/32))*CF.A(-0.9+0*M.C(Sine/32),M.R(-5),-0.5+0.1*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(1,2-.05*M.C(Sine/32),0+0*M.C(Sine/32))*CF.A(0.9+0*M.C(Sine/32),M.R(-5),0.1+0*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='ISOLATION')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    								    				    				Effect({
Color = BrickColor.new'Dark blue'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.new'Really black'.Color;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10,0.5,10);
					EndSize=Vector3.new(10,0.5,10);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0+2*M.S(Sine/32),2+1*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(0+10*M.S(Sine/32)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-30*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.7,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.7,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.3+0.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.9-.05*M.C(Sine/32),-0.5)*CF.A(0+0.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='K A R M A')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
Size = Vector3.new(0, 0.01, 3*music.PlaybackLoudness/40),
EndSize = Vector3.new(0-music.PlaybackLoudness/40, 0, 0-music.PlaybackLoudness/40),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
Size = Vector3.new(3*music.PlaybackLoudness/40, 0.01, 0),
EndSize = Vector3.new(0-music.PlaybackLoudness/40, 0, 0-music.PlaybackLoudness/40),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})
					
																							Effect{
				Lifetime=0.5;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-20,20),math.random(-20,20),math.random(-20,20)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(2,2,2);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(-30+6*M.S(Sine/32)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-100*M.S(Sine/1)),M.R(-5+100*M.S(Sine/1)),0+100*M.S(Sine/1)),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,0.4+.05*M.S(Sine/32),0)*CF.A(2.4,M.R(5+30*M.C(Sine/1)),M.R(50-30*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.3,0.4+.05*M.S(Sine/32),0)*CF.A(2.4,M.R(5-30*M.C(Sine/1)),M.R(-50+30*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.9)*CF.A(-0.3+0.2*M.C(Sine/32),M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.6+0.2*M.C(Sine/32),M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='VISUALIZER')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(13+music.PlaybackLoudness/100,0.5,13+music.PlaybackLoudness/100);
					EndSize=Vector3.new(13+music.PlaybackLoudness/100,0.5,13+music.PlaybackLoudness/100);
					}
					
																			Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Brick};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10+music.PlaybackLoudness/100,0.5,10+music.PlaybackLoudness/100);
					EndSize=Vector3.new(10+music.PlaybackLoudness/100,0.5,10+music.PlaybackLoudness/100);
					}
				    
RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+.4*M.C(Sine/39),-0)*CF.A(M.R(20+5*M.S(Sine/32)),M.R(0+5*M.C(Sine/24)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.7,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0+music.PlaybackLoudness/500,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.5)*CF.A(0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(1.2,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='ALTERATION')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				    				    				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.06, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+3.5*M.C(Sine/50),4+1*M.C(Sine/25),0+2*M.S(Sine/32))*CF.A(M.R(50+5*M.S(Sine/50)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6-.05*M.C(Sine/32),-0.7)*CF.A(-0.5+0.2*M.C(Sine/32),M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7+0.2*M.C(Sine/32),M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
															elseif(Mode=='DISTORTION')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				    				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.06, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    																	    local HCF = Root.CFrame * CF.N(math.random(-10,20),-4,(math.random(-10,10))) * CF.A(M.R(math.random(-0,0)),M.R(math.random(-0,0)),M.R(math.random(-0,0)))
Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0,0,0),
EndSize = Vector3.new(0.4,1,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
				    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+3.5*M.C(Sine/50),4+1*M.C(Sine/25),0+2*M.S(Sine/32))*CF.A(M.R(50+5*M.S(Sine/50)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.4+.05*M.S(Sine/32),0)*CF.A(1.8,M.R(15+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.7,M.R(5-5*M.C(Sine/32)),M.R(15+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.9)*CF.A(-0.5+0.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8+0.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='Cycle')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    Effect({
Color = Color3.fromRGB(0, 0, 255),
Material = Enum.Material.Neon,
Mesh = "Blast",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(10, 0.01, 10),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/1),0)*CF.A(M.R(-20+20*M.S(Sine/1)),M.R(0+20*M.S(Sine/1)),0+0.3*M.S(Sine/1)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.4,M.R(5-5*M.C(Sine/32)),M.R(15+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.45,M.R(-5),-0.1+-0.08*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.45,M.R(-5),0.1+0.08*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='disturbance')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.13, 0.06, 0.13),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-0,0)),M.R(math.random(-0,0)),M.R(math.random(-0,0)))
Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,5,0),
Size = Vector3.new(1,1,1),
EndSize = Vector3.new(1,1,1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    																	    local HCF = Root.CFrame * CF.N(math.random(-10,20),-4,(math.random(-10,10))) * CF.A(M.R(math.random(-0,0)),M.R(math.random(-0,0)),M.R(math.random(-0,0)))
Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0,0,0),
EndSize = Vector3.new(0.2,1,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
				    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+3.5*M.C(Sine/50),4+1*M.C(Sine/25),0+2*M.S(Sine/32))*CF.A(M.R(50+5*M.S(Sine/50)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.2-.05*M.C(Sine/32),-1)*CF.A(-0.2,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
														elseif(Mode=='lost')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    local HCF = Torso.CFrame * CF.N(math.random(-2,2),-4,(math.random(-2,2))) * CF.A(M.R(math.random(-2,2)),M.R(math.random(-2,2)),M.R(math.random(-2,2)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Glass,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,-10,0),
Size = Vector3.new(.1,.1,0.1),
EndSize = Vector3.new(.3,.3,.3),
Transparency = NumberRange.new(0,0),
Lifetime = 0.25,
})
			local Alpha = .1
						    			    				GotEffect{
					Lifetime=.001;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,-2.2,0)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Color=BrickColor.new'Black'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10,2,5);
					EndSize=Vector3.new(10,2,5);
				}
				
								    				    				Effect({
Color = BrickColor.new'Lilac'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.new'Black'.Color;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10,0.5,10);
					EndSize=Vector3.new(10,0.5,10);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(0+10*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.5+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.5+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.5)*CF.A(1.0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1-.05*M.C(Sine/32),-0.3)*CF.A(0.5,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='IMMORTALITY')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				    				Effect({
Color = BrickColor.new'Grey'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(10+5*M.S(Sine/32)),M.R(-20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.4+.1*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(15+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0.4)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),-0.4)*CF.A(0.2,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
															elseif(Mode=='HAUNTED')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				    
				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-20+5*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.6-.05*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				

				
															elseif(Mode=='Collected')then
				local Alpha = .1
				if(NeutralAnims)then
				    				    
				    				Effect({
Color = Color3.fromRGB(255, 255, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.3,
})
 
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.5*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.5,M.R(5+5*M.C(Sine/32)),M.R(10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.5,M.R(5-5*M.C(Sine/32)),M.R(-10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-1,-0.1-.2*M.C(Sine/32),-0.4)*CF.A(-0.9,M.R(15),0.7),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(1,-0.1-.2*M.C(Sine/32),-0.4)*CF.A(-0.9,M.R(-15),-0.7),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
											elseif(Mode=='SPEED OF LIGHT')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(0+10*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,0+0.2*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(160+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.3,.3,-0.5)*CF.A(M.R(30.5+3.5*M.S(Sine/24)),M.R(15),M.R(-8.3)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.5)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='YING-YANG')then
				local Alpha = .1
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.2,0.2,0.2);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.2,0.2,0.2);
				}	
				

				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1+0*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.05*M.S(Sine/32),-0.5)*CF.A(-4.6,M.R(5+10*M.C(Sine/32)),M.R(40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.05*M.S(Sine/32),-0.5)*CF.A(-4.6,M.R(5-10*M.C(Sine/32)),M.R(-40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-75),0,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.5)*CF.A(0,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='INFINITE')then
				local Alpha = .1
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				

				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+3*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(150+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				


				
				
											elseif(Mode=='Sub-Normal')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,-0.6+.05*M.S(Sine/32),-0.4)*CF.A(2.4,M.R(5+5*M.C(Sine/32)),M.R(30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-20),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

			elseif(Mode=='Normal')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(25),M.R(5+5*M.C(Sine/32)),M.R(-0-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(40),M.R(5-5*M.C(Sine/32)),M.R(0+5*M.C(Sine/32))),Alpha)
				end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(-5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(5)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
							elseif(Mode=='Evicted')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    							    GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Maroon'.Color;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,15,0.2);
				}	
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0.8,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5-.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3-.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='SIMULATION')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
Effect({
Color = Color3.fromRGB(0, 100, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    				    							    			    				GotEffect{
					Lifetime=.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame=Torso.CFrame*CF.N(0,1.5,-5)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Color=BrickColor.new'Camo'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(10,10,0.5);
				}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+1*M.C(Sine/32),0)*CF.A(M.R(40+12*M.S(Sine/32)),M.R(10+6*M.C(Sine/32)),-0.2),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0+.05*M.S(Sine/32),-0.3)*CF.A(2.5,M.R(5+5*M.C(Sine/32)),M.R(30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.3*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.6-.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5+.2*M.C(Sine/32),-0.5)*CF.A(-0.3-.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Mystical')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Med. reddish violet'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
				GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Med. reddish violet'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
								    				Effect({
Color = Color3.fromRGB(255, 100, 100),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0+2*M.S(Sine/32),2+1*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(0+10*M.S(Sine/32)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.4,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.4,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.25*M.C(Sine/32),0)*CF.A(-0.5+.25*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5+.25*M.C(Sine/32),-0.5)*CF.A(-0.3+.25*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='DISSAPOINTMENT')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(-20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0.4,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(0.4+.2*M.C(Sine/32),M.R(10),-0.04),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(0.4+.2*M.C(Sine/32),M.R(-2),0.04),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
											elseif(Mode=='Blaze')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright orange'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(0+10*M.S(Sine/64)),M.R(0+15*M.S(Sine/64)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,-0.5+.2*M.S(Sine/32),-0.4)*CF.A(2.4,M.R(5+5*M.C(Sine/32)),M.R(30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5+.2*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='OBLITERATION')then
				local Alpha = .1
				if(NeutralAnims)then	
				    Effect{
				    					Lifetime=0.8;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0.9,9,-2)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={0.9,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.3,0.6);
					EndSize=Vector3.new(15,0.5,15);
				}
				
		    														Effect{
				Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(255, 0, 0),
				    CFrame=Torso.CFrame*CF.N(0.9,9,-2)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0.9,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10,10,10);
					EndSize=Vector3.new(10,10,10);
					}
				
																							Effect{
				Lifetime=0.1;
					Mesh='Ring';
					Color=PrimaryColor;
					CFrame = Torso.CFrame* CF.N(0.9,9,-2) * CF.A(30,M.R(math.random(-0,0)),0),
					Transparency={0.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(1.5,1.5,0.5);
					}
					
									    
				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(160+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
							elseif(Mode=='CMD:_____')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(2.5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
							elseif(Mode=='CaTAstOphIc')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(2.5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
							elseif(Mode=='OVERDRIVE')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(30+10*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.6,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.6,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.1+.2*M.C(Sine/32),M.R(-5),-0.1+.1*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.5)*CF.A(0.3+.2*M.C(Sine/32),M.R(-5),0.1-.1*M.C(Sine/32)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

				
			elseif(Mode=='S P A C E T I M E')then
				local Alpha = .1
								    																		    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Dark blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
																	GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Dark blue'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+0.4*M.C(Sine/32),0)*CF.A(M.R(20+3*M.S(Sine/64)),0,0.14),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.7,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.6)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
				--cheeseburger
											elseif(Mode=='M A L I C E')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
					
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(30+5*M.S(Sine/32)),M.R(10+1*M.S(Sine/32)),0+0.2*M.S(Sine/64)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0-.2*M.C(Sine/32),M.R(5+5*M.C(Sine/32)),M.R(-30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0-.2*M.C(Sine/32),M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.05*M.C(Sine/32),-1)*CF.A(-0.3-.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5-.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			elseif(Mode=='F0RG0TT3N')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.4+.05*M.C(Sine/32),0)*CF.A(M.R(-20+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(-150+5*M.C(Sine/32)),M.R(-75-2*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(150-5*M.C(Sine/32)),M.R(75+2*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-65),-0.2,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.4-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(7),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='CURSED')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    			    
				    				    				Effect({
Color = BrickColor.new'Maroon'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.4+.05*M.C(Sine/32),0)*CF.A(M.R(-20+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-65),-0.2,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.4-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(7),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='PUNISHED')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.4+.05*M.C(Sine/32),0)*CF.A(M.R(-20+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.1,-0+.3*M.S(Sine/32),-0)*CF.A(M.R(175),M.R(-0),M.R(25-4*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.1,0+.3*M.S(Sine/32),0)*CF.A(M.R(175),M.R(5-4*M.C(Sine/32)),M.R(-25-4*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-65),-0.2,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.4-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(7),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
										elseif(Mode=='BROKEN')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    																							Effect{
				Lifetime=0.1;
					Mesh='Ring';
					Color=PrimaryColor;
					CFrame = Torso.CFrame* CF.N(0,9,9.5) * CF.A(0.7,M.R(math.random(-0,0)),0),
					Transparency={0.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(1.5,1.5,0.5);
					}
					
									    Effect{
				    					Lifetime=0.8;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,9,9.5)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0.9,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.3,0.6);
					EndSize=Vector3.new(15,0.5,15);
				}
				
		    														Effect{
				Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(0, 0, 0),
				    CFrame=Torso.CFrame*CF.N(0,9,9.5)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={0.9,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10,10,10);
					EndSize=Vector3.new(10,10,10);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.4+.05*M.C(Sine/32),0)*CF.A(M.R(-20+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0.5)*CF.A(M.R(-65),-0.2,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.4-.05*M.C(Sine/32),-0.5)*CF.A(0.3,M.R(7),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				
											elseif(Mode=='INEVITABLE')then
				local Alpha = .1
				if(NeutralAnims)then	
									RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/50),3+0.2*M.C(Sine/25),0+1*M.S(Sine/32))*CF.A(M.R(30+5*M.S(Sine/50)),0+0.2*M.S(Sine/50),0+0.2*M.S(Sine/50)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(-15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5+.2*M.C(Sine/32),-0.3)*CF.A(-0.3+.2*M.C(Sine/32),M.R(10),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.4+.2*M.C(Sine/32),M.R(-10),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
					
					
				end
				
				
				
							elseif(Mode=='L')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='Omnipotent')then
				    
				    				Effect({
Color = Color3.fromRGB(255, 255, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(10+10*M.S(Sine/64)),M.R(0),0.4),Alpha)  
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(160+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
				LH.C0 = LH.C0:lerp(LSC0*CF.N(1,-1+.0*M.S(Sine/32),-0.5)*CF.A(-.3 + .7*M.C(Sine/16),M.R(0+0*M.C(Sine/32)),M.R(-0-0*M.C(Sine/32))),Alpha)
				RH.C0 = RH.C0:lerp(RSC0*CF.N(-1,-1+.0*M.S(Sine/32),-0.5)*CF.A(-.3 + -.7*M.C(Sine/16),M.R(0-0*M.C(Sine/32)),M.R(0+0*M.C(Sine/32))),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='EXCALIBUR')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.0*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(10-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
											elseif(Mode=='EXCALIBUR X')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(10-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.8,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

							elseif(Mode=='OMEGA')then
				local Alpha = .1
				if(NeutralAnims)then	
RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/50),3+0.2*M.C(Sine/25),0+1*M.S(Sine/32))*CF.A(M.R(10+5*M.S(Sine/50)),0+0.1*M.S(Sine/50),0+0.1*M.S(Sine/50)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.6+.05*M.S(Sine/32),0)*CF.A(2.3,M.R(5+5*M.C(Sine/32)),M.R(-20-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.6+.05*M.S(Sine/32),0)*CF.A(2.3,M.R(5-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.5,0+.2*M.C(Sine/32),-0.3)*CF.A(-0.7,M.R(-5),0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.5,0+.2*M.C(Sine/32),-0.3)*CF.A(-0.7,M.R(-5),-0.4),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='SYSTEM_32')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				Effect({
Color = BrickColor.new'Maroon'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.4+.1*M.S(Sine/32),-0.8)*CF.A(2,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.3+.1*M.S(Sine/32),-0.8)*CF.A(1,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.9-.05*M.C(Sine/32),-0.9)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='bored')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+0*M.C(Sine/32),-0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(90+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.8)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='Deleterious')then
							    
							    										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(.0,0,.0);
					}
							    
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+.7*M.C(Sine/32),-0)*CF.A(M.R(0+5*M.S(Sine/32)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(90+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.8)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='Liar X')then
																									    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
																					    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}	    
										    
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(-30+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
    				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(100-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.3,.3,-0.5)*CF.A(M.R(30.5+3.5*M.S(Sine/24)),M.R(15),M.R(2)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.5)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(2)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
						elseif(Mode=='HYPNOTIC')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/64),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(25),M.R(5+5*M.C(Sine/32)),M.R(-20-10*M.C(Sine/64))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(40),M.R(5-5*M.C(Sine/32)),M.R(20+10*M.C(Sine/64))),Alpha)
				end
			if(legAnims)then 
				if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.5,M.R(-5),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.5,M.R(-5),0.2),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
				
											elseif(Mode=='ARCADE')then
				local Alpha = .1
				if(NeutralAnims)then	
                	RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+.7*M.C(Sine/39),6+.6*M.C(Sine/32),0)*CF.A(M.R(-2+5*M.S(Sine/58)),M.R(-15+5*M.C(Sine/42)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0+.05*M.S(Sine/32),-0.6)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(210+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='ILLUSION')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(5,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.7,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.6)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='I N S A N E')then
							    
							    				    				Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.3,
})
			
							    
							    
							    				    
				    								    																		    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(2, 2, 2),
EndSize = Vector3.new(2, 2,2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

								    																		    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
							    
							    																					    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
												    																																		GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
							    
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='PSYCHO')then
										    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
							    
							    																					    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
												    																																		GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
							    
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5+5*M.C(Sine/32)),M.R(-40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-1,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='Volcanic')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(40+5*M.C(Sine/32)),M.R(-50-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(-40-5*M.C(Sine/32)),M.R(50+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),0.4),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
									elseif(Mode=='HYPERSKIDDED')then
				local Alpha = .1
				if(NeutralAnims)then	
				    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.random().Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,4,0.1),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

																			Effect{
				Lifetime=0.2;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
				    CFrame=Torso.CFrame*CF.N(0,0.4,-0.56)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Transparency={.9,.9};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(10,10,10);
					}

Effect({
Color = BrickColor.random().Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = BrickColor.random().Color;
Material = Enum.Material.Neon,
Mesh = "Slash2",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})



				    
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.random().Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.random().Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.random().Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.random().Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1+0*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/1),0)*CF.A(-0.5,M.R(5+30*M.C(Sine/1)),M.R(-10-30*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/1),0)*CF.A(-0.5,M.R(5-30*M.C(Sine/1)),M.R(10+30*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-75),0,M.R(-5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.5)*CF.A(0,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='DIMENSIONAL')then
				local Alpha = .1
				if(NeutralAnims)then
				    				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
												GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				    
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(40+5*M.C(Sine/32)),M.R(-50-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(-40-5*M.C(Sine/32)),M.R(50+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),0.4),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='Inferno')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    
												    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Neon orange'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
									    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/20),0)*CF.A(M.R(20+10*M.S(Sine/20)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.2,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				                            elseif(Mode=='DETERMEND')then
                local Alpha = .1
                if(NeutralAnims)then    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,8+1*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0+.0*M.C(Sine/32)),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.4+.2*M.S(Sine/32),0)*CF.A(2.4,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.6,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
                end
                if(legAnims)then 
                    if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(-0.8+.2*M.C(Sine/32),M.R(-5),-0+0.1*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,.7-.2*M.C(Sine/32),-0.5)*CF.A(-0.3+.2*M.C(Sine/32),M.R(-5),0+-0.1*M.C(Sine/32)),Alpha)
                    else
                        LH.C0 = LH.C0:lerp(LHC0,Alpha)
                        RH.C0 = RH.C0:lerp(RHC0,Alpha)
                    end
                end
                
                                            elseif(Mode=='A N O M A L O U S')then
                local Alpha = .1
                if(NeutralAnims)then    
                    
                    
Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
                    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-225-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
                end
                if(legAnims)then 
                    if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6-.05*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-1,M.R(-5),0),Alpha)
                    else
                        LH.C0 = LH.C0:lerp(LHC0,Alpha)
                        RH.C0 = RH.C0:lerp(RHC0,Alpha)
                    end
                end
                
                       elseif(Mode=='SCURRILITY')then
            local Alpha = .1
            if(NeutralAnims)then    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(0+5*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.4,M.R(5+5*M.C(Sine/32)),M.R(-30-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.4,M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
            end
            if(legAnims)then 
                if(NeutralAnims)then
                        LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.5)*CF.A(-0.4,M.R(30),-0),Alpha)
                        RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.5)*CF.A(-0.4,M.R(-30),0),Alpha)
                else
                    LH.C0 = LH.C0:lerp(LHC0,Alpha)
                    RH.C0 = RH.C0:lerp(RHC0,Alpha)
                end
            end
				
											elseif(Mode=='FUTURE')then
				local Alpha = .1
				if(NeutralAnims)then	
				    				    				Effect({
Color = BrickColor.new'Lilac'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright blue'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
									    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Lilac'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(40+5*M.C(Sine/32)),M.R(40-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(-40-5*M.C(Sine/32)),M.R(-40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='deterioration')then
				local Alpha = .1
				if(NeutralAnims)then					    																	    
				    local HCF = Root.CFrame * CF.N(math.random(-20,20),10,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.random().Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,-10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

														    
														    																																Effect{
				Lifetime=0.00001;
					Mesh='Cloud';
                    Color = BrickColor.new'Really black'.Color;
					CFrame = Root.CFrame* CF.N(0,17,0) * CF.A(0,M.R(math.random(0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(50,30,50);
					EndSize=Vector3.new(50,30,50);
					}
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+0.6*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(10),10),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-100*M.S(Sine/1)),M.R(-5+100*M.S(Sine/1)),0+100*M.S(Sine/1)),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0+.05*M.S(Sine/32),-0.3)*CF.A(2.5,M.R(5+5*M.C(Sine/32)),M.R(30-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-0.1*M.C(Sine/32),-0.6)*CF.A(-0.3-0.2*M.C(Sine/32),M.R(20-5*M.C(Sine/32)),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5-0.2*M.C(Sine/32),M.R(-20-5*M.C(Sine/32)),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
																			    
														    																																
				end
				
				
				
										elseif(Mode=='acidic')then
			local Alpha = .1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.2+.25*M.C(Sine/0.5),0)*CF.A(M.R(-45+1*M.S(Sine/64)),M.R(0),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.95,0.,M.R(-5.5)),Alpha)
					RH.C0 = RH.C0:lerp(LHC0*CF.N(1,-0.2-.05*M.C(Sine/32),-1)*CF.A(-0.95,0.,M.R(-5.5)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
				
				
				
							elseif(Mode=='Hydro')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+2*M.C(Sine/32),0)*CF.A(M.R(-40+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,-.2+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.3,-.2+.05*M.S(Sine/32),.1)*CF.A(M.R(-25),M.R(5-2.5*M.C(Sine/32)),M.R(-35+1.5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='₴₱ØØ₭ł₮Ɏ₴')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(-30+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0+.05*M.S(Sine/32),-0.6)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(210+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.3-.05*M.C(Sine/32),-1)*CF.A(150,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(100,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='E̶̠̰͕͔͂̐̓̾Ņ̷̢̗̖̰̗̤̘̈́̅̿̑Ḓ̶͍̖̗͇̞͓͈͕̌͂̍͗́͗͑̿͊͝ͅĻ̸̨̥̼̳̖̟͗̅̍̔͗̀̉̆͌̍E̴̘̝̘̻̞͗̂͒͛͊̀͘͝S̷͖̯̳̲̲͛͒̓͊Ş̷̩͇̣͙̩͓̺̎ͅ ̷̢͙̹͙̀̽͑̊̇̚̚͠S̷̡̱̠̳̻̖̳̻̉͌͋̒͌̔́I̴̢̼͈̩͛͑̚L̷̡͔̰̩̺̱͌͆́̓̋̆̓̈͘E̶̡͇̽̾͜N̷̛̼̺̈́̿̑̀͛͑̓͠͝C̴͍͔̆͊͋̅̕͜Ē̸̛̯͔̥̜̺͆')then
				local Alpha = .1
				if(NeutralAnims)then	
		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,12+2*M.C(Sine/32),0)*CF.A(M.R(-35+1*M.S(Sine/64)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-155-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='SHATTERED')then
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,5,0),
Size = Vector3.new(0.3,0.3,0.3),
EndSize = Vector3.new(0.3,0.3,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 2,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-10,10),-4,(math.random(-10,10))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,7,0),
Size = Vector3.new(0.5,0,0.5),
EndSize = Vector3.new(0.3,10,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then	
RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+.4*M.C(Sine/39),-0)*CF.A(M.R(20+5*M.S(Sine/32)),M.R(0+5*M.C(Sine/24)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.7,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.7,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.5)*CF.A(0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(1.2,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='FADING')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(40+5*M.C(Sine/32)),M.R(-50-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(-40-5*M.C(Sine/32)),M.R(50+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.4,M.R(-5),0.4),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='CURED')then
				local Alpha = .1
				
										    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,2,0),
Size = Vector3.new(0.7,0,0.7),
EndSize = Vector3.new(15,15,15),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+2*M.C(Sine/32),0)*CF.A(M.R(0+5*M.S(Sine/32)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-140-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(140+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.5,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='Relax')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+.4*M.C(Sine/32),0)*CF.A(M.R(80+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.4,0.4+.05*M.S(Sine/32),0.3)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-230-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.4,0.4+.05*M.S(Sine/32),0.3)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(230+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.5,M.R(-9),0.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-9),-0.5),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Euclidiean')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+.4*M.C(Sine/32),0)*CF.A(M.R(40+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.3-.05*M.C(Sine/32),-0.4)*CF.A(-0.4,M.R(30),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.7,M.R(-30),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			elseif(Mode=='Calamity')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				Effect({
Color = BrickColor.new'Pink'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Pink'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(20+10*M.S(Sine/32)),M.R(-20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
								LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0.1+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-84+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.6-.05*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='80s')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='Corruption')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-20),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='WORMHOLE')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+.5*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.1,-0+.05*M.S(Sine/32),-0)*CF.A(M.R(175),M.R(-0),M.R(25-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.1,0+.05*M.S(Sine/32),0)*CF.A(M.R(175),M.R(5-2.5*M.C(Sine/32)),M.R(-25-1.5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.1,0.7-.05*M.C(Sine/32),-0.5)*CF.A(-0.4,M.R(-5),0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.3-.05*M.C(Sine/32),-0.3)*CF.A(-0.6,M.R(-5),-0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
											elseif(Mode=='UNMERCIFUL')then
							    				    
local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(2, 2, 2),
EndSize = Vector3.new(2, 2,2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.4,
})

				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/20),0)*CF.A(M.R(20+10*M.S(Sine/20)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-200-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.7,-0.3+.2*M.S(Sine/32),-0.4)*CF.A(0,M.R(-10-5*M.C(Sine/32)),M.R(-90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.0-.05*M.C(Sine/32),-00)*CF.A(-0.5,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.6-.05*M.C(Sine/32),-0.8)*CF.A(-0.2,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='WITHERED')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(2,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1,M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.7)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='90s')then
				local Alpha = .1
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+.4*M.C(Sine/32),0)*CF.A(M.R(50+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
    				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(100-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.5,M.R(-9),0.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-9),-0.5),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				

				
				
				
				
				
											elseif(Mode=='R E M E M B E R E D')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+3*M.C(Sine/32),0)*CF.A(M.R(20+10*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-160-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(70-5*M.C(Sine/32)),M.R(75+2*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.8,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				
				
			elseif(Mode=='DESTROYED')then
				local Alpha = .1
									GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(20+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-1,M.R(5+5*M.C(Sine/32)),M.R(-160-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.7,-0.3+.2*M.S(Sine/32),-0.4)*CF.A(-0.5,M.R(-10-5*M.C(Sine/32)),M.R(-90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),-0)*CF.A(-0.7+.2*M.C(Sine/32),M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.9)*CF.A(-0.5+.2*M.C(Sine/32),M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
				

							elseif(Mode=='GREATSWORD')then
				local Alpha = .1
					
										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/1)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),7,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,100,M.R(2.5)),Alpha)
					end
				end
			elseif(Mode=='Catastrophe')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+1*M.C(Sine/32),0)*CF.A(M.R(10+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.01*M.C(Sine/32),-0.4)*CF.A(-0.5,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.5,0,M.R(2.5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
			elseif(Mode=='Cataclysm')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(5,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.01*M.C(Sine/32),-0.4)*CF.A(-0.5,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,0,M.R(2.5)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
			elseif(Mode=='Radioactivity')then
				local Alpha = .1
				
													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Camo'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Lime green'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Camo'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Lime green'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+2*M.C(Sine/32),0.6)*CF.A(M.R(40+3*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
									RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.4+.2*M.S(Sine/32),0)*CF.A(0.8,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),-0)*CF.A(-0.7+.2*M.C(Sine/32),M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.9)*CF.A(-0.5+.2*M.C(Sine/32),M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
					end
				end
											elseif(Mode=='Mythical')then
				local Alpha = .1
				    
				    				Effect({
Color = Color3.fromRGB(255, 100, 100),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-30,30)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				 
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/1)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),7,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0.1+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-84+1*M.S(Sine/36))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.A(0,100,M.R(2.5)),Alpha)
					end
				end
							elseif(Mode=='SOLITUDE')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-30+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(30-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.6,0.5+.05*M.S(Sine/32),-0.5+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-30+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
											elseif(Mode=='【Ｊｕｓｔｉｃｅ】')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,60+1*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(10),-0.3+-0.1*M.C(Sine/32)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.4+.2*M.S(Sine/32),0)*CF.A(0.8,M.R(5+5*M.C(Sine/32)),M.R(-30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,-0.2+.2*M.S(Sine/32),0)*CF.A(0.8,M.R(5-5*M.C(Sine/32)),M.R(-60+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5,M.R(15),0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.8)*CF.A(-0.2,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
								elseif(Mode=='【P e r s e v e r a n c e】')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,40+5*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(10),-0.3+-0.1*M.C(Sine/32)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0.6+.1*M.S(Sine/32),-0.3)*CF.A(3.1,M.R(10-2*M.C(Sine/30)),M.R(40+1*M.C(Sine/28))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.8,-0.4+.1*M.S(Sine/32),-0.5)*CF.A(2.2,M.R(3-0*M.C(Sine/32)),M.R(-65+.2*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5,M.R(15),0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.8)*CF.A(-0.2,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='【P u r e】')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,30+5*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(10),-0.3+-0.1*M.C(Sine/32)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0+0.3*M.S(Sine/32),0.2)*CF.A(-0.7,M.R(6+2*M.C(Sine/32)),M.R(45-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.2,-0.8+.05*M.S(Sine/32),-0.7)*CF.A(2.2,M.R(20-15*M.C(Sine/30)),M.R(-0+10*M.C(Sine/28))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5,M.R(15),0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.8)*CF.A(-0.2,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='Cautious')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.1*M.C(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/64)),M.R(0),-0.0+-0.0*M.C(Sine/32)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-20-1.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,-0.0+.05*M.S(Sine/32),-0.3)*CF.A(0,M.R(-35+1*M.C(Sine/32)),M.R(-25-2*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.8,-0.4+.0*M.S(Sine/32),-0.5)*CF.A(2.2,M.R(3-0*M.C(Sine/32)),M.R(-65+.2*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.1,0-.1*M.C(Sine/32),-0.3)*CF.A(0.0,M.R(25),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.2,0.0-.1*M.C(Sine/32),0.0)*CF.A(0.0,M.R(-35),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='APEX')then
	
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0+0.1*M.S(Sine/64),-0.3+.2*M.C(Sine/64),0)*CF.A(M.R(10+0*M.S(Sine/64)),M.R(0),-0.0+0.1*M.S(Sine/64)),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-5.5*M.S(Sine/32)),M.R(-35),0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(-0.1,-0.0+.05*M.S(Sine/32),-0.0)*CF.A(0,M.R(-0+0*M.C(Sine/64)),M.R(-25+10*M.C(Sine/64))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0.1,-0.0+.05*M.S(Sine/32),-0.0)*CF.A(0.0,M.R(0-0*M.C(Sine/64)),M.R(25-10*M.C(Sine/64))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0-0.1*M.S(Sine/64),-0.2-.2*M.C(Sine/64),-0.1)*CF.A(-0.5,M.R(10),-0.3-0.1*M.S(Sine/64)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0-0.1*M.S(Sine/64),-0.15-.2*M.C(Sine/64),-0.5)*CF.A(0.1,M.R(-25),0.4-0.1*M.S(Sine/64)),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='INTRICACY // LASTSTAR')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3.0+2*M.C(Sine/64),0)*CF.A(M.R(10+0*M.S(Sine/64)),M.R(0),-0.1+-0.1*M.C(Sine/32)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-5.5*M.S(Sine/32)),M.R(-75),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0.6+.1*M.S(Sine/32),-0.3)*CF.A(3.1,M.R(10-2*M.C(Sine/30)),M.R(40+1*M.C(Sine/28))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0.0,0+0.1*M.S(Sine/32),0.2)*CF.A(-0.7,M.R(6-2*M.C(Sine/32)),M.R(-35-5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0.0,-0.0-.05*M.C(Sine/32),-0.0)*CF.A(-0.1,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.2,0.9-0.2*M.C(Sine/32),-0.6)*CF.A(0.1-0.3,M.R(-25),0.3),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='WARPSPEED // LASTSTAR')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.4+.1*M.C(Sine/32),0)*CF.A(M.R(-30+1*M.S(Sine/64)),M.R(0),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(25-0.2*M.S(Sine/32)),M.R(-15),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(2,M.R(-360+10*M.C(Sine/32)),M.R(-90-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.8,-0.4+.1*M.S(Sine/32),-0.5)*CF.A(2.0,M.R(3-0*M.C(Sine/32)),M.R(-45+.2*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.1,0-.1*M.C(Sine/32),-0.1)*CF.A(0.0,M.R(25),-0.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.2,0.3-.1*M.C(Sine/32),-0.3)*CF.A(0.5,M.R(-5),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='NOMODEUSE')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(5+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
																			elseif(Mode=='totally real immortality lord')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(10),0),Alpha)
					if(M.RNG(1,25)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.4,M.R(5+5*M.C(Sine/32)),M.R(-15-10*M.C(Sine/35))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(0+0*M.C(Sine/35))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+0*M.C(Sine/32),0)*CF.A(0.5+.3*M.S(Sine/32),M.R(15),-0-.06*M.S(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+0*M.C(Sine/32),0)*CF.A(0.4+.2*M.S(Sine/32),M.R(-15),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
																			elseif(Mode=='Wasteland')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    


				    
				    																			Effect{
				Lifetime=0.1;

					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,0};
					Material=Enum.Material.Grass;
					Size=Vector3.new(200,0.5,200);
					EndSize=Vector3.new(200,0.5,200);
					}
					
									    																			Effect{
				Lifetime=0.1;

					Mesh='Cloud';
					Color=Color3.fromRGB(150, 150, 150);
					CFrame = Root.CFrame* CF.N(10,-3,-10) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,0};
					Material=Enum.Material.Grass;
					Size=Vector3.new(10,10,10);
					EndSize=Vector3.new(10,10,10);
					}
					
														    																			Effect{
				Lifetime=0.1;

					Mesh='Cloud';
					Color=Color3.fromRGB(150, 150, 150);
					CFrame = Root.CFrame* CF.N(32,-3,26) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,0};
					Material=Enum.Material.Grass;
					Size=Vector3.new(10,10,10);
					EndSize=Vector3.new(10,10,10);
					}
					
																			    																			Effect{
				Lifetime=0.1;

					Mesh='Cloud';
					Color=Color3.fromRGB(150, 150, 150);
					CFrame = Root.CFrame* CF.N(-32,-3,16) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,0};
					Material=Enum.Material.Grass;
					Size=Vector3.new(10,10,10);
					EndSize=Vector3.new(10,10,10);
					}
					
														    																			Effect{
				Lifetime=0.1;

					Mesh='Cloud';
					Color=Color3.fromRGB(30, 30, 30);
					CFrame = Root.CFrame* CF.N(0,40,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,0};
					Material=Enum.Material.Grass;
					Size=Vector3.new(150,20,150);
					EndSize=Vector3.new(150,20,150);
					}
					
														    																			Effect{
				Lifetime=0.1;

					Mesh='Cloud';
					Color=Color3.fromRGB(150, 150, 150);
					CFrame = Root.CFrame* CF.N(-10,-3,60) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,0};
					Material=Enum.Material.Grass;
					Size=Vector3.new(10,10,10);
					EndSize=Vector3.new(10,10,10);
					}
					
																			    																			Effect{
				Lifetime=0.1;

					Mesh='Cloud';
					Color=Color3.fromRGB(150, 150, 150);
					CFrame = Root.CFrame* CF.N(-10,-3,-60) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,0};
					Material=Enum.Material.Grass;
					Size=Vector3.new(10,10,10);
					EndSize=Vector3.new(10,10,10);
					}
					
																			    																			Effect{
				Lifetime=0.1;

					Mesh='Cloud';
					Color=Color3.fromRGB(150, 150, 150);
					CFrame = Root.CFrame* CF.N(40,-3,-40) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,0};
					Material=Enum.Material.Grass;
					Size=Vector3.new(10,10,10);
					EndSize=Vector3.new(10,10,10);
					}
					
					-- Trunk Functions
					
					-- pos: 10,2,13
					-- pos: -32,2,42
local HCF = Root.CFrame * CF.N(10,-4,-10) * CF.A(M.R(-23,23),M.R(-24,24),M.R(-31,31))
Effect({
Color = Color3.fromRGB(78,53,36),
Material = Enum.Material.Wood,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(1,20,1),
Transparency = NumberRange.new(0,0),
Lifetime = 0.1,
})



local HCF = Root.CFrame * CF.N(42,-4,-46) * CF.A(M.R(-24,-4),M.R(19,16),M.R(-5,25))
Effect({
Color = Color3.fromRGB(78,53,36),
Material = Enum.Material.Wood,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(1,15,1),
Transparency = NumberRange.new(0,0),
Lifetime = 0.1,
})



local HCF = Root.CFrame * CF.N(8,-4,12) * CF.A(M.R(-13,-16),M.R(-20,24),M.R(8,17))
Effect({
Color = Color3.fromRGB(78,53,36),
Material = Enum.Material.Wood,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(1,15,1),
Transparency = NumberRange.new(0,0),
Lifetime = 0.1,
})

local HCF = Root.CFrame * CF.N(21,-4,43) * CF.A(M.R(21,16),M.R(-11,8),M.R(-10,-12))
Effect({
Color = Color3.fromRGB(78,53,36),
Material = Enum.Material.Wood,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(1,15,1),
Transparency = NumberRange.new(0,0),
Lifetime = 0.1,
})



local HCF = Root.CFrame * CF.N(37,-4,29) * CF.A(M.R(21,16),M.R(-11,8),M.R(-10,-12))
Effect({
Color = Color3.fromRGB(78,53,36),
Material = Enum.Material.Wood,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(1,15,1),
Transparency = NumberRange.new(0,0),
Lifetime = 0.1,
})
-- WASTEROT3
local HCF = Root.CFrame * CF.N(50,-4,-32) * CF.A(M.R(21,16),M.R(-11,8),M.R(-10,-12))
Effect({
Color = Color3.fromRGB(78,53,36),
Material = Enum.Material.Wood,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(1,15,1),
Transparency = NumberRange.new(0,0),
Lifetime = 0.1,
})

local HCF = Root.CFrame * CF.N(-50,-4,-32) * CF.A(M.R(21,16),M.R(-11,8),M.R(-10,-12))
Effect({
Color = Color3.fromRGB(78,53,36),
Material = Enum.Material.Wood,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(1,15,1),
Transparency = NumberRange.new(0,0),
Lifetime = 0.1,
})

local HCF = Root.CFrame * CF.N(-32,-4,34) * CF.A(M.R(13,13),M.R(-24,24),M.R(-13,-13))
Effect({
Color = Color3.fromRGB(78,53,36),
Material = Enum.Material.Wood,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(1,15,1),
Transparency = NumberRange.new(0,0),
Lifetime = 0.1,
})

local HCF = Root.CFrame * CF.N(-43,-4,10) * CF.A(M.R(16,16),M.R(29,29),M.R(-25,-25))
Effect({
Color = Color3.fromRGB(78,53,36),
Material = Enum.Material.Wood,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(1,15,1),
Transparency = NumberRange.new(0,0),
Lifetime = 0.1,
})

local HCF = Root.CFrame * CF.N(0,-4,-42) * CF.A(M.R(16,16),M.R(29,29),M.R(-25,-25))
Effect({
Color = Color3.fromRGB(78,53,36),
Material = Enum.Material.Wood,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(1,15,1),
Transparency = NumberRange.new(0,0),
Lifetime = 0.1,
})

local HCF = Root.CFrame * CF.N(math.random(-50, 50),40,math.random(-50, 50)) * CF.A(M.R(0,0),M.R(-0,-0),M.R(0,0))
Effect({
Color = Color3.fromRGB(0,255,0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,-80,0),
Size = Vector3.new(0.5,0.5,0.5),
EndSize = Vector3.new(0.5,0.5,0.5),
Transparency = NumberRange.new(0,0),
Lifetime = 1.5,
})









					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(20+10*M.S(Sine/32)),M.R(20+10*M.C(Sine/32)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.4+.2*M.S(Sine/32),-0.5)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-180-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.1*M.S(Sine/32),-0.8)*CF.A(1,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.9+.2*M.C(Sine/32),-0.7)*CF.A(-0.3+.2*M.C(Sine/32),M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5+.2*M.C(Sine/32),M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='My Return')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(30+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,-0.9+.05*M.S(Sine/32),-0.6)*CF.A(1.4,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0.4)*CF.A(3.4,M.R(5+5*M.C(Sine/32)),M.R(-70-5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.05*M.C(Sine/32),-0.7)*CF.A(-0.4,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='TRAUMATIZED')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(M.R(30+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.2+.2*M.S(Sine/32),0)*CF.A(-0.6,M.R(5+5*M.C(Sine/math.random(1,15))),M.R(-15-30*M.C(Sine/math.random(1,15)))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.2+.2*M.S(Sine/32),0)*CF.A(-0.6,M.R(5-5*M.C(Sine/math.random(1,15))),M.R(15+30*M.C(Sine/math.random(1,15)))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/32),0.7)*CF.A(-1,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-0.3-.2*M.C(Sine/32),-0.2)*CF.A(-0.4,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='EXPLOITED')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(-20),-0.2),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-210-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.8,M.R(5-5*M.C(Sine/32)),M.R(-15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(15),0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.6-.05*M.C(Sine/32),-0.7)*CF.A(-0.3,M.R(-15),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='Amalgamate')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(25+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,-1.8+.2*M.S(Sine/32),0.5)*CF.A(-0.4,M.R(5+5*M.C(Sine/32)),M.R(5-0*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0.5,-1.2+.2*M.S(Sine/32),-0.4)*CF.A(2.4,M.R(5-5*M.C(Sine/32)),M.R(5+0*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LSC0*CF.N(0.1,0.5+.2*M.S(Sine/32),-0.4)*CF.A(-0.4,M.R(5+5*M.C(Sine/32)),M.R(5-0*M.C(Sine/32))),Alpha)
					RH.C0 = RH.C0:lerp(RSC0*CF.N(0,0.5+.2*M.S(Sine/32),0.3)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(15+0*M.C(Sine/32))),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='STEAMPUNK')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(5+1*M.S(Sine/64)),M.R(50),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.2+.2*M.S(Sine/32),0)*CF.A(0.4,M.R(5+5*M.C(Sine/32)),M.R(15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.2+.2*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4+.2*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='Studio')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(30+10*M.S(Sine/32)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0.4)*CF.A(3.4,M.R(5+5*M.C(Sine/32)),M.R(70-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.9+.2*M.C(Sine/32),-0.8)*CF.A(-0.2+.1*M.C(Sine/32),M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.1+.2*M.C(Sine/32),-0.5)*CF.A(1+.1*M.C(Sine/32),M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
														elseif(Mode=='DEATH')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+2*M.C(Sine/32),0)*CF.A(M.R(25+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,-0.4+.2*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.4+.2*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.6)*CF.A(-0.3+.2*M.C(Sine/32),M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.6+.2*M.C(Sine/32),M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='HACKER101')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				    							    			    				GotEffect{
					Lifetime=.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame=Torso.CFrame*CF.N(0,1.5,-5)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Color=BrickColor.new'Camo'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(10,10,0.5);
				}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1.3*M.C(Sine/32),0)*CF.A(M.R(10+5*M.S(Sine/32)),M.R(10),-0.2),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-140-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5-5*M.C(Sine/32)),M.R(-30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.7)*CF.A(-0.2,M.R(15),0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.6,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='RELAXED')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+1*M.C(Sine/64),0)*CF.A(M.R(70+10*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.4,0.2+.05*M.S(Sine/32),0)*CF.A(0.3,M.R(5-5*M.C(Sine/32)),M.R(220+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.3-.05*M.C(Sine/32),-0.4)*CF.A(-0.9,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-0.4)*CF.A(-0.8,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='SPEED')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/15),3+0.2*M.C(Sine/15),0+1*M.S(Sine/15))*CF.A(M.R(20+5*M.S(Sine/15)),0+0.1*M.S(Sine/15),0+0.1*M.S(Sine/15)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.2*M.S(Sine/15),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.2*M.S(Sine/15),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/15),0)*CF.A(-0.6,M.R(30),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.6+.2*M.C(Sine/15),-0.5)*CF.A(-0.3,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='STORM')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
Effect({
                    Color = BrickColor.new'Lime green'.Color;
                    Material = Enum.Material.Grass,
                    Mesh = "Block",
                    Transparency={0,1};
                    CFrame = Root.CFrame* CF.N(math.random(-360,360),-3,math.random(-180,180)) * CF.A(1.5,M.R(math.random(-360,180)),0),
                    EndPos = Root.CFrame* CF.N(0,2,0) * CF.A(0,M.R(math.random(-180,180)),0),
                    Size = Vector3.new(2, 2, 2),
                    EndSize = Vector3.new(2, 2, 2),
                    wdLifetime = 0.1,
                })
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(5+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(1.9,M.R(5+5*M.C(Sine/32)),M.R(-35-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(1.9,M.R(5-5*M.C(Sine/32)),M.R(35+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4+.2*M.C(Sine/32),-0.6)*CF.A(-0.6,M.R(15),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4+.3*M.C(Sine/32),-0.6)*CF.A(-0.5,M.R(-15),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='DESCENTION')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.1+.05*M.C(Sine/32),0)*CF.A(M.R(-30+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.3,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1.1-.05*M.C(Sine/32),-0.8)*CF.A(0.4,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='Administration')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(5+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.3+.05*M.S(Sine/32),0)*CF.A(3.7,M.R(5-5*M.C(Sine/32)),M.R(0+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='IMPERFECTION')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.7+.2*M.S(Sine/32),0)*CF.A(2.3,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.4,0+.05*M.S(Sine/32),0.8)*CF.A(0.5,M.R(5-5*M.C(Sine/32)),M.R(-10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5+.1*M.C(Sine/32),M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.6+.2*M.C(Sine/32),-0.9)*CF.A(-0.3+.2*M.C(Sine/32),M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='MALWARE')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
							    				    																							Effect{
				Lifetime=0.5;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-20,20),math.random(-20,20),math.random(-20,20)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(2,2,2);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/50),3+0.3*M.C(Sine/25),0+1*M.S(Sine/32))*CF.A(M.R(20+5*M.S(Sine/50)),0+0.3*M.S(Sine/50),0+0.1*M.S(Sine/50)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.2+.2*M.S(Sine/32),0)*CF.A(0+-.5*M.S(Sine/32),M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.2+.2*M.S(Sine/32),0)*CF.A(0+-.5*M.S(Sine/32),M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5+.2*M.C(Sine/32),-0.4)*CF.A(-0.3+.2*M.C(Sine/32),M.R(15+10*M.C(Sine/32)),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),-0.5)*CF.A(-0.7+.2*M.C(Sine/32),M.R(-15+10*M.C(Sine/32)),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='ANARCHY')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/50),3+0.2*M.C(Sine/25),0+1*M.S(Sine/32))*CF.A(M.R(20+5*M.S(Sine/50)),0+0.1*M.S(Sine/50),0+0.1*M.S(Sine/50)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0.6,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,-0.2+.2*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.3+.2*M.C(Sine/32),-0.6)*CF.A(-0.3+.1*M.C(Sine/32),M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.6+.1*M.C(Sine/32),M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
										elseif(Mode=='Immortal')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/50),3+0.2*M.C(Sine/25),0+1*M.S(Sine/32))*CF.A(M.R(20+5*M.S(Sine/50)),0+0.1*M.S(Sine/50),0+0.1*M.S(Sine/50)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-90-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.6)*CF.A(-0.3,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.6,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='MURDER')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.9+.2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/math.random(1, 15))),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.4,M.R(5+5*M.C(Sine/32)),M.R(-15-15*M.C(Sine/math.random(1, 15)))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6-.2*M.C(Sine/32),-0.4)*CF.A(-0.8,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.2*M.C(Sine/32),-0.5)*CF.A(-0.5,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='CRAZY')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0+0.2*M.C(Sine/15),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.3,M.R(5+5*M.C(Sine/32)),M.R(-15-30*M.C(Sine/math.random(1, 15)))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.01,0+.05*M.S(Sine/32),0)*CF.A(2.4,M.R(5-5*M.C(Sine/32)),M.R(-15+30*M.C(Sine/math.random(1, 15)))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/15),-0)*CF.A(-0,M.R(15),-0.15),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.2*M.C(Sine/15),-0)*CF.A(-0,M.R(-15),0.15),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='CORPSE')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/50),3+0.2*M.C(Sine/25),0+1*M.S(Sine/32))*CF.A(M.R(30+10*M.S(Sine/50)),0+0.2*M.S(Sine/50),0+0.2*M.S(Sine/50)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,-0.2+.2*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.5+.2*M.S(Sine/32),0)*CF.A(2.4,M.R(5-5*M.C(Sine/32)),M.R(20+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.9+.2*M.C(Sine/32),-0.8)*CF.A(-0.2+.1*M.C(Sine/32),M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.1+.2*M.C(Sine/32),-0.5)*CF.A(1+.1*M.C(Sine/32),M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='Flouressent')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				Effect({
Color = Color3.fromRGB(100, 100, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/50),3+0.2*M.C(Sine/25),0+1*M.S(Sine/32))*CF.A(M.R(20+5*M.S(Sine/50)),0+0.1*M.S(Sine/50),0+0.1*M.S(Sine/50)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.3,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.3,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5+.2*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(10+5*M.C(Sine/32)),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.6,M.R(-10+5*M.C(Sine/32)),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
					
					
				end
				
															elseif(Mode=='Ruptured')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(0, 0, 0);
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4+music.PlaybackLoudness/50,0.2,4+music.PlaybackLoudness/50);
					EndSize=Vector3.new(3+music.PlaybackLoudness/50,0.2,3+music.PlaybackLoudness/50);
					}
					
									    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(40, 0, 0);
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/50,0.5,3+music.PlaybackLoudness/50);
					EndSize=Vector3.new(3+music.PlaybackLoudness/50,0.5,3+music.PlaybackLoudness/50);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/50),3+0.2*M.C(Sine/25),0+1*M.S(Sine/32))*CF.A(M.R(30+10*M.S(Sine/50)),0+0.2*M.S(Sine/50),0+0.2*M.S(Sine/50)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-1.3-0.4*M.C(Sine/50),M.R(5+5*M.C(Sine/32)),M.R(-40-10*M.C(Sine/50))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-1.3-0.4*M.C(Sine/50),M.R(5-5*M.C(Sine/32)),M.R(40+10*M.C(Sine/50))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.7+.2*M.C(Sine/32),M.R(30),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.6+.2*M.C(Sine/32),-0.5)*CF.A(-0.3+.2*M.C(Sine/32),M.R(-30),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='EXECUTION')then
				local Alpha = .1
				if(NeutralAnims)then	
									RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/50),3+0.2*M.C(Sine/25),0+1*M.S(Sine/32))*CF.A(M.R(30+10*M.S(Sine/50)),0+0.2*M.S(Sine/50),0+0.2*M.S(Sine/50)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.8+.2*M.S(Sine/32),0)*CF.A(2.4,M.R(5+5*M.C(Sine/32)),M.R(-10-10*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(60+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/32),-0)*CF.A(-0.8+.4*M.C(Sine/32),M.R(5+4*M.C(Sine/32)),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1-.2*M.C(Sine/32),-0.7)*CF.A(-0+.1*M.C(Sine/32),M.R(-5+4*M.C(Sine/32)),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
					
					
				end
				
															elseif(Mode=='[ HI ]')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(10+5*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(20-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(2.3,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6+.2*M.C(Sine/32),-0.4)*CF.A(-0.5+.1*M.C(Sine/32),M.R(10+5*M.C(Sine/32)),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4+.2*M.C(Sine/32),-0.5)*CF.A(-0.5+.1*M.C(Sine/32),M.R(-10-5*M.C(Sine/32)),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
					
					
				end
				
															elseif(Mode=='GUN')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(5+1*M.S(Sine/64)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,-0.2+.05*M.S(Sine/32),-0.8)*CF.A(1.0,M.R(5+5*M.C(Sine/32)),M.R(30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.2+.05*M.S(Sine/32),0)*CF.A(1.3,M.R(5-5*M.C(Sine/32)),M.R(-30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(30),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-30),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='OVERRIDDEN')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				Effect({
Color = Color3.fromRGB(40, 40, 40),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(20+10*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(-15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.3-.2*M.C(Sine/32),-0.3)*CF.A(-0.7,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.6-.2*M.C(Sine/32),-0.7)*CF.A(-0.3,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='TRANSCENDANCE')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4+music.PlaybackLoudness/3,0.2,4+music.PlaybackLoudness/3);
					EndSize=Vector3.new(3+music.PlaybackLoudness/3,0.2,3+music.PlaybackLoudness/3);
					}
					
									    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.new("Gold");
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/3,0.5,3+music.PlaybackLoudness/3);
					EndSize=Vector3.new(3+music.PlaybackLoudness/3,0.5,3+music.PlaybackLoudness/3);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.3*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.3*M.S(Sine/32),0)*CF.A(2.4,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5+.3*M.C(Sine/32),-0.4)*CF.A(-0.3-.1*M.C(Sine/32),M.R(40),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.3*M.C(Sine/32),0)*CF.A(-0.3-.1*M.C(Sine/32),M.R(-25),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='PREHISTORIC')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4+music.PlaybackLoudness/100,0.2,4+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.2,3+music.PlaybackLoudness/100);
					}
					
									    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(40, 0, 60);
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					}
					
									    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
                    Color = Color3.fromRGB(40, 0, 60);
					Transparency={1,0};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2,3,2);
					EndSize=Vector3.new(0.1,0.1,0.1);
				}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(5+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.3,M.R(5+5*M.C(Sine/32)),M.R(-30-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5+.2*M.C(Sine/32),-0.5)*CF.A(-0.4,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4+.2*M.C(Sine/32),-0.4)*CF.A(-0.5,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='Ancient')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    				Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright orange'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(10+5*M.S(Sine/32)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,-0.5+.2*M.S(Sine/32),-0.4)*CF.A(2.4,M.R(5+5*M.C(Sine/32)),M.R(30-15*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-.2*M.C(Sine/32),-0.3)*CF.A(-0.3,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.2*M.C(Sine/32),-0.6)*CF.A(-0.7,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='MAYHEM')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
								    				    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.2,1,0.2);
					EndSize=Vector3.new(0.2,5,0.2);
				}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.1*M.C(Sine/32),0)*CF.A(M.R(5+1*M.S(Sine/64)),M.R(-50),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.05*M.S(Sine/32),0)*CF.A(-0.6,M.R(5+5*M.C(Sine/32)),M.R(-200-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.3,M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.2,0-.1*M.C(Sine/32),-0.1)*CF.A(0,M.R(40),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.1*M.C(Sine/32),0)*CF.A(0,M.R(-20),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				-----------Star glitcher---------------
				
																			elseif(Mode=='!MAYHEM!')then
				local Alpha = .1
				if(NeutralAnims)then	
						RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.1+.1*M.C(Sine/32),0)*CF.A(M.R(-15+1*M.S(Sine/64)),M.R(0),0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-0-0.0*M.S(Sine/32)),M.R(35),0),Alpha)
					end
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0.6+.1*M.S(Sine/32),-0.3)*CF.A(3.1,M.R(10-2*M.C(Sine/30)),M.R(40+1*M.C(Sine/28))),Alpha)
						RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.1+.1*M.S(Sine/32),0)*CF.A(-0.0,M.R(0-0*M.C(Sine/math.random(1,15))),M.R(25+0*M.C(Sine/math.random(1,15)))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.1,-0.3-.1*M.C(Sine/32),-0.1)*CF.A(0.8,M.R(55),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.1,-0.1-.1*M.C(Sine/32),-0.1)*CF.A(-0.3,M.R(-30),0.3),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
				
				elseif(Mode==':joy:')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
				    
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.3*M.C(Sine/32),0)*CF.A(M.R(5+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.7+-0.7*M.C(Sine/32),M.R(5+5*M.C(Sine/32)),M.R(-25-20*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.7+-0.7*M.C(Sine/32),M.R(5-5*M.C(Sine/32)),M.R(25+20*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.3-.3*M.C(Sine/32),-0.1)*CF.A(0,M.R(30),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-0.3-.3*M.C(Sine/32),-0.1)*CF.A(0,M.R(-30),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='GALACTIC')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(100, 0, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,7,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					}
					
									    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
				GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}

				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+1*M.C(Sine/32),0)*CF.A(M.R(30+10*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.3+.2*M.S(Sine/32),0)*CF.A(-0.8,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.3+.2*M.S(Sine/32),0)*CF.A(2.3,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6-.05*M.C(Sine/32),-0.8)*CF.A(-0.3+.2*M.C(Sine/32),M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(1+.2*M.C(Sine/32),M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='labyrinth')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/32),0)*CF.A(M.R(-30+5*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,0+.2*M.S(Sine/32),0)*CF.A(2.4,M.R(5+5*M.C(Sine/32)),M.R(30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.2*M.S(Sine/32),0)*CF.A(2.4,M.R(5-5*M.C(Sine/32)),M.R(-30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7-.2*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='PROBLEMATIC')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
				GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
																		Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					}
				
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2*M.C(Sine/32),0)*CF.A(M.R(-15+10*M.S(Sine/32)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.3+.2*M.S(Sine/32),0)*CF.A(0.4,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.3+.2*M.S(Sine/32),0)*CF.A(1.6,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.1+.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.5)*CF.A(0.3+.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
																			elseif(Mode=='Ω')then
				local Alpha = .1
				if(NeutralAnims)then
				    
					    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(10+5*M.S(Sine/64)),M.R(10),0.3),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,-0.1+.2*M.S(Sine/32),-0.5)*CF.A(1.6,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.3,-0.1+.2*M.S(Sine/32),-0.5)*CF.A(1.3,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5+.2*M.C(Sine/32),-0.8)*CF.A(-0.3,M.R(-5),0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4+.2*M.C(Sine/32),-0.5)*CF.A(-0.6,M.R(-5),-0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='PERSERVERENCE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				Effect({
Color = Color3.fromRGB(255, 255, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(20+5*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.2+.2*M.S(Sine/32),-0.5)*CF.A(1.6,M.R(5+5*M.C(Sine/32)),M.R(90-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.2*M.S(Sine/32),-0.5)*CF.A(0.4,M.R(5-5*M.C(Sine/32)),M.R(-70+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.3)*CF.A(-0.3-.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.3+.2*M.C(Sine/32),-0.7)*CF.A(-0.7-.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='ENTROPY')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Dark blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(15+5*M.S(Sine/64)),M.R(0+10*M.S(Sine/64)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(1.9,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(-15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-.2*M.C(Sine/32),-0.5)*CF.A(-0.5-.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.6-.2*M.C(Sine/32),-0.7)*CF.A(-0.7-.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='ALIVE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
								    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Pastel light blue'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}    
				
								    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(0+10*M.S(Sine/64)),M.R(0+15*M.S(Sine/64)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.4+.2*M.S(Sine/32),0)*CF.A(1.4,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(160+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.8)*CF.A(-0.3+.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5+.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				
															elseif(Mode=='RITUALISTIC')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    																							Effect{
				Lifetime=0.4;
					--Mesh={Type=Enum.MeshType.Sphere};
					Part = 'Sword',
					Color=PrimaryColor;
					CFrame = Root.CFrame* CF.N(math.random(-20,20),-3,math.random(-20,20)) * CF.A(1.5,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=V3.N(0.8,2.5,6.8);
					EndSize=V3.N(0.8,2.5,16);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/32),0)*CF.A(M.R(-40+10*M.S(Sine/32)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-50*M.S(Sine/1)),M.R(-5+50*M.S(Sine/1)),0+50*M.S(Sine/1)),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.7+.2*M.S(Sine/32),-0.6)*CF.A(2.5,M.R(5+5*M.C(Sine/32)),M.R(15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),-0.6)*CF.A(2.4,M.R(5-5*M.C(Sine/32)),M.R(-100+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7-.2*M.C(Sine/32),-0.8)*CF.A(-0.3+.2*M.S(Sine/32),M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(-0.7+.2*M.S(Sine/32),M.R(-20),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='MERCILESS')then
				local Alpha = .1
				if(NeutralAnims)then
				    
																							Effect{
				Lifetime=0.4;
					--Mesh={Type=Enum.MeshType.Sphere};
					Part = 'Sword',
					Color=PrimaryColor;
					CFrame = Root.CFrame* CF.N(math.random(-20,20),-3,math.random(-20,20)) * CF.A(1.5,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=V3.N(0.8,2.5,6.8);
					EndSize=V3.N(0.8,2.5,16);
					}
				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/40,0.5,3+music.PlaybackLoudness/40);
					EndSize=Vector3.new(3+music.PlaybackLoudness/40,0.5,3+music.PlaybackLoudness/40);
					}
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/32),0)*CF.A(M.R(15+5*M.S(Sine/32)),M.R(10+5*M.S(Sine/32)),0.2),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(1.8,M.R(5-5*M.C(Sine/32)),M.R(40+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.6)*CF.A(-0.3+.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.6+.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
													elseif(Mode=='BEYOND')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				Effect({
Color = Color3.fromRGB(255, 0, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(-10+3*M.S(Sine/32)),M.R(-20+10*M.S(Sine/32)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0.1+.2*M.S(Sine/32),0)*CF.A(2.4,M.R(5+5*M.C(Sine/32)),M.R(30-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.6+.2*M.S(Sine/32),0)*CF.A(2,M.R(5-5*M.C(Sine/32)),M.R(-25+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6+.2*M.C(Sine/32),-0.7)*CF.A(-0.4,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
															elseif(Mode=='LUNAR')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
								    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Pastel light blue'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
				
								    				Effect({
Color = Color3.fromRGB(150, 150, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Pastel light blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(40+5*M.S(Sine/32)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0+.2*M.S(Sine/32),-0.3)*CF.A(2.5,M.R(5+5*M.C(Sine/32)),M.R(30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0.4,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4+.2*M.C(Sine/32),-0.9)*CF.A(-0.3+.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2+.2*M.C(Sine/32),-0.5)*CF.A(-0.6+.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end

			elseif(Mode=='Fearless')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+1*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
							elseif(Mode=='E0RR0R')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0.5,M.R(5+5*M.C(Sine/32)),M.R(15-10*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(15+10*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.3,M.R(10),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5+.2*M.C(Sine/32),-0.8)*CF.A(-0.5,M.R(-10),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
      elseif(Mode=='4TH DIMENSION')then
            local Alpha = .1
            if(NeutralAnims)then    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-30+5*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.4+.05*M.S(Sine/32),0)*CF.A(-0.6,M.R(5+5*M.C(Sine/32)),M.R(-210-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.4+.05*M.S(Sine/32),0)*CF.A(-0.6,M.R(5-5*M.C(Sine/32)),M.R(210+5*M.C(Sine/32))),Alpha)
            end
            if(legAnims)then 
                if(NeutralAnims)then
                        LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-10),-0),Alpha)
                        RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.6,M.R(10),0),Alpha)
                else
                    LH.C0 = LH.C0:lerp(LHC0,Alpha)
                    RH.C0 = RH.C0:lerp(RHC0,Alpha)
                end
            end
            
             elseif(Mode=='BURN!')then
            local Alpha = .1
            if(NeutralAnims)then    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-30+5*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.4+.05*M.S(Sine/32),0)*CF.A(-0.6,M.R(5+5*M.C(Sine/32)),M.R(-210-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.4+.05*M.S(Sine/32),0)*CF.A(-0.6,M.R(5-5*M.C(Sine/32)),M.R(210+5*M.C(Sine/32))),Alpha)
            end
            if(legAnims)then 
                if(NeutralAnims)then
                        LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-10),-0),Alpha)
                        RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.6,M.R(10),0),Alpha)
                else
                    LH.C0 = LH.C0:lerp(LHC0,Alpha)
                    RH.C0 = RH.C0:lerp(RHC0,Alpha)
                end
            end
            
             elseif(Mode=='GODS REVENGE')then
local Alpha = .1
				if(NeutralAnims)then	
				    
				    				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-40),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,-.2+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(170+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.2)*CF.A(0,M.R(20),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-0.4)*CF.A(0,M.R(-20),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
            
            elseif(Mode=='..End of the World..')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0*M.C(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='Limitless')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0.9,0+0*M.C(Sine/32),0)*CF.A(M.R(1+0*M.S(Sine/64)),M.R(50),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-25-5.5*M.S(Sine/32)),M.R(-50),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(2,M.R(10+10*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.4,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.0,0-.05*M.C(Sine/32),0)*CF.A(-0.0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.0,0-.05*M.C(Sine/32),0)*CF.A(0.0,M.R(-25),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='Stalker')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0.9,0+0*M.C(Sine/32),0)*CF.A(M.R(1+0*M.S(Sine/64)),M.R(50),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-25-5.5*M.S(Sine/32)),M.R(-50),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(2,M.R(10+10*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.4,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.0,0-.05*M.C(Sine/32),0)*CF.A(-0.0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0.0,0-.05*M.C(Sine/32),0)*CF.A(0.0,M.R(-25),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
            
             elseif(Mode=='!DEATH DEATH AND MORE DEATHS!')then
            local Alpha = .1
            if(NeutralAnims)then    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-30+5*M.S(Sine/64)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.4+.05*M.S(Sine/32),0)*CF.A(-0.6,M.R(5+5*M.C(Sine/32)),M.R(-210-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.4+.05*M.S(Sine/32),0)*CF.A(-0.6,M.R(5-5*M.C(Sine/32)),M.R(210+5*M.C(Sine/32))),Alpha)
            end
            if(legAnims)then 
                if(NeutralAnims)then
                        LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-10),-0),Alpha)
                        RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.6,M.R(10),0),Alpha)
                else
                    LH.C0 = LH.C0:lerp(LHC0,Alpha)
                    RH.C0 = RH.C0:lerp(RHC0,Alpha)
                end
            end
            
            elseif(Mode=='PROPHECY')then
        local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0*M.C(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				 elseif(Mode=='Killa')then
	local Alpha = .1
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				

				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+3*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),-0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(150+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
									LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.4,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.5,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
				elseif(Mode=='Coded')then
       	local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.7+.2*M.S(Sine/32),0)*CF.A(2.3,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.4,0+.05*M.S(Sine/32),0.8)*CF.A(0.5,M.R(5-5*M.C(Sine/32)),M.R(-10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5+.1*M.C(Sine/32),M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.6+.2*M.C(Sine/32),-0.9)*CF.A(-0.3+.2*M.C(Sine/32),M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
					elseif(Mode=='UNEXEPTIONAL_E0RROR')then
       local Alpha = .1
				if(NeutralAnims)then	
				    
				    							    GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Maroon'.Color;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,15,0.2);
				}	
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+1*M.C(Sine/32),0)*CF.A(M.R(-20+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0.8,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5-.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.5)*CF.A(-0.3-.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			
			elseif(Mode=='SINGULARITY')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,0+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(150-1.5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(35+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.6,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.8,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
															elseif(Mode=='UNSTABLE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
Size = Vector3.new(0, 0.01, 3*music.PlaybackLoudness/70),
EndSize = Vector3.new(0-music.PlaybackLoudness/70, 0, 0-music.PlaybackLoudness/70),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
Size = Vector3.new(3*music.PlaybackLoudness/70, 0.01, 0),
EndSize = Vector3.new(0-music.PlaybackLoudness/70, 0, 0-music.PlaybackLoudness/70),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-1.7+.3*M.C(Sine/20),0)*CF.A(M.R(5+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-100*M.S(Sine/1)),M.R(-5+100*M.S(Sine/1)),0+100*M.S(Sine/1)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-40*M.C(Sine/math.random(1,15))),M.R(-3.3-40*M.C(Sine/math.random(1,15))),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-40*M.C(Sine/math.random(1,15))),M.R(-3.3-40*M.C(Sine/math.random(1,15))),M.R(-146.5)),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.9-.3*M.C(Sine/20),-0.8)*CF.A(0.3,M.R(15+2*M.C(Sine/20)),-0.2),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.9-.3*M.C(Sine/20),-0.8)*CF.A(0.3,M.R(-15-2*M.C(Sine/20)),0.2),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
				
							elseif(Mode=='HAZARDOUS')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    				    
				    				Effect({
Color = Color3.fromRGB(186, 143, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,20,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,20,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+2*M.C(Sine/32),0)*CF.A(M.R(-40+5*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-225-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),-0)*CF.A(-0.8,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7-.05*M.C(Sine/32),-1)*CF.A(-0.6,M.R(-5),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			
			
															elseif(Mode=='FOUND')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(-35+5*M.S(Sine/32)),M.R(30),-0.1),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.6,M.R(5+5*M.C(Sine/32)),M.R(-30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.6+.2*M.S(Sine/32),-0.5)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(180+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.3,M.R(15),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.7+.2*M.C(Sine/32),-0.9)*CF.A(-0.2,M.R(-15),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			
									elseif(Mode=='Corroded')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
				    								    																		    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Grey'.Color;
Material = Enum.Material.CorrodedMetal,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+2*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
					if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-40*M.C(Sine/math.random(1,15))),M.R(-3.3-40*M.C(Sine/math.random(1,15))),M.R(146.5)),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(0.4,M.R(5-5*M.C(Sine/32)),M.R(10+10*M.C(Sine/32))),Alpha)
				end
			if(legAnims)then 
				if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(0.5+.3*M.S(Sine/32),M.R(15),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(0.4+.2*M.S(Sine/32),M.R(-15),0),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
			
									elseif(Mode=='CHAOS')then
				local Alpha = .1
				if(NeutralAnims)then	
				    
local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.random().Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,4,0.1),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(25),M.R(5+5*M.C(Sine/32)),M.R(-5-10*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0+.05)*CF.A(M.R(40),M.R(5-5*M.C(Sine/32)),M.R(5+10*M.C(Sine/32))),Alpha)
				end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.0*M.C(Sine/32),0)*CF.A(M.R(27),0,M.R(-3)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.0*M.C(Sine/32),0)*CF.A(M.R(27),0,M.R(3)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
											elseif(Mode=='MURDEROUS')then
				local Alpha = .1
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+1*M.C(Sine/50),3+0.2*M.C(Sine/25),0+1*M.S(Sine/32))*CF.A(M.R(20+5*M.S(Sine/50)),0+0.1*M.S(Sine/50),0+0.1*M.S(Sine/50)),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.3,-0.2+.2*M.S(Sine/32),-0.4)*CF.A(-0.4,M.R(5+5*M.C(Sine/32)),M.R(-200-0*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.2+.2*M.S(Sine/32),0)*CF.A(-0.8,M.R(5-5*M.C(Sine/32)),M.R(-30+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.5-.2*M.C(Sine/32),-0.5)*CF.A(-0.3,M.R(15),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(-0.6,M.R(-15),0.1),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			end
		elseif(State == 'Walk')then
				if(Mode=='DESTROYED')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    									GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
			elseif(Mode=='80s')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='Corruption')then
			local wsVal = 7
			local Alpha = 1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end


elseif(Mode=='サイコ')then
			local wsVal = 1
			local Alpha = 1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.0,0+.1*M.S(Sine/32),0.3)*CF.A(-1.3,M.R(5+5*M.C(Sine/32)),M.R(-20-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.0,0+.1*M.S(Sine/32),0.3)*CF.A(-1.3,M.R(5-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.0*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.0*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

elseif(Mode=='REDEMPTION')then
			local wsVal = 12
			local Alpha = 1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+0*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-0-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.08*M.S(Sine/32),0)*CF.A(M.R(0+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(-25-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0.1)*CF.A(M.R(0-45*(movement/12)*M.S(Sine/wsVal))*forwardvelocity,-0.1,0.2),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.0*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.0*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

elseif(Mode=='Eradicating')then
			local wsVal = 8
			local Alpha = 1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+Change/8*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*32.5)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(-0+0*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(-0-1*M.C(Sine/wsVal))),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0.1)*CF.A(M.R(0+35*(movement/12)*M.S(Sine/wsVal))*forwardvelocity,0.1,0.1),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0.1)*CF.A(M.R(0-35*(movement/12)*M.S(Sine/wsVal))*forwardvelocity,-0.1,0.0),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.2+.0*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.2+.0*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

elseif(Mode=='GLITCHED')then
			local wsVal = 3
			local Alpha = 1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+Change/8*M.C(Sine/(wsVal/4)),0)*CF.A(M.R(-(Change*45.5)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(-0+0*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(-0-1*M.C(Sine/wsVal))),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0.1)*CF.A(M.R(0+110*(movement/12)*M.S(Sine/wsVal))*forwardvelocity,0.2,0.0),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0.1)*CF.A(M.R(0-110*(movement/12)*M.S(Sine/wsVal))*forwardvelocity,-0.2,-0.0),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.6+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.6+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

elseif (Mode=='Expitition')then
			local wsVal = 3
			local Alpha = 1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+Change/8*M.C(Sine/(wsVal/4)),0)*CF.A(M.R(-(Change*45.5)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(-0+0*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(-0-1*M.C(Sine/wsVal))),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0.1)*CF.A(M.R(0+110*(movement/12)*M.S(Sine/wsVal))*forwardvelocity,0.2,0.0),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0.1)*CF.A(M.R(0-110*(movement/12)*M.S(Sine/wsVal))*forwardvelocity,-0.2,-0.0),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.6+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.6+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end



elseif(Mode=='COLLAPSED')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 			    	LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(-1,0,M.R(-7+5*M.S(Sine/32))),Alpha)
  			    	RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(-1,0,M.R(7-5*M.S(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				elseif(Mode=='EMPERATOR')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 			    	LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(-1,0,M.R(-7+5*M.S(Sine/32))),Alpha)
  			    	RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(-1,0,M.R(7-5*M.S(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				elseif(Mode=='ERR0R')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 			    	LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(-1,0,M.R(-7+5*M.S(Sine/32))),Alpha)
  			    	RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(-1,0,M.R(7-5*M.S(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				elseif(Mode=='XENOPHERIC')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 			    	LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(-1,0,M.R(-7+5*M.S(Sine/32))),Alpha)
  			    	RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(-1,0,M.R(7-5*M.S(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				elseif(Mode=='V E L D U S')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    									GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
				    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				    
				  				    				Effect({
Color = Color3.fromRGB(255, 0, 40),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,20,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,20,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})     
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(4+2*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 			    	LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(-1,0,M.R(-7+5*M.S(Sine/32))),Alpha)
  			    	RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(-1,0,M.R(7-5*M.S(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(25-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end

elseif(Mode=='P A I N')then
			local wsVal = 25
			local Alpha = 1
			if(NeutralAnims)then
			RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.4+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*30)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.08*M.S(Sine/32),-0.7)*CF.A(M.R(75+0*M.S(Sine/32)),M.R(0+0*M.C(Sine/32)),M.R(85-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0)*CF.A(M.R(0-40*(movement/25)*M.S(Sine/wsVal))*forwardvelocity,0,0),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.4-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+0*forwardvelocity))*CF.A((M.R(-5*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+0*forwardvelocity))*CF.A((M.R(-5*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end






























			elseif(Mode=='Administration')then
			local wsVal = 7
			local Alpha = 1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.3+.05*M.S(Sine/32),0)*CF.A(3.7,M.R(5-5*M.C(Sine/32)),M.R(0+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='GUN')then
			local wsVal = 7
			local Alpha = 1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,-0.2+.05*M.S(Sine/32),-0.8)*CF.A(1.0,M.R(5+5*M.C(Sine/32)),M.R(30-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.2+.05*M.S(Sine/32),0)*CF.A(1.3,M.R(5-5*M.C(Sine/32)),M.R(-30+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='CRAZY')then
			local wsVal = 7
			local Alpha = 1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5+5*M.C(Sine/32)),M.R(-15-15*M.C(Sine/math.random(1,15)))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5-5*M.C(Sine/32)),M.R(15+15*M.C(Sine/math.random(1,15)))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end											

			elseif(Mode=='TRAUMATIZED')then
			local wsVal = 7
			local Alpha = 1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5+5*M.C(Sine/32)),M.R(-15-15*M.C(Sine/math.random(1,15)))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5-5*M.C(Sine/32)),M.R(15+15*M.C(Sine/math.random(1,15)))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end


			elseif(Mode=='MURDER')then
			local wsVal = 7
			local Alpha = 1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5+5*M.C(Sine/32)),M.R(-15-15*M.C(Sine/math.random(1,15)))),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='DEMENTED')then
			local wsVal = 7
			local Alpha = 1
			
			 
				    																							Effect{
				Lifetime=0.2;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.random().Color;
    				CFrame = Torso.CFrame* CF.N(math.random(-20,20),math.random(-20,20),math.random(-20,20)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(2,2,2);
					}
					
									    																							Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.random().Color;
					CFrame = Root.CFrame* CF.N(0,10,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,0};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2+music.PlaybackLoudness/100,2+music.PlaybackLoudness/100,2+music.PlaybackLoudness/100);
					EndSize=Vector3.new(2+music.PlaybackLoudness/100,2+music.PlaybackLoudness/100,2+music.PlaybackLoudness/100);
					}
					
																																	Effect{
				Lifetime=0.01;
					Mesh='Ring';
                    Color = BrickColor.random().Color;
					CFrame = Root.CFrame* CF.N(0,10,0) * CF.A(29.8,M.R(math.random(-0,0)),0),
					Transparency={0,0};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.1+music.PlaybackLoudness/250,0.1+music.PlaybackLoudness/250,0.1);
					EndSize=Vector3.new(0.1+music.PlaybackLoudness/250,0.1+music.PlaybackLoudness/250,0.1);
					}
			
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

		elseif(Mode=='CURSED')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
			    
			    				    			    
				    				    				Effect({
Color = BrickColor.new'Maroon'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
			    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

		elseif(Mode=='DESCENTION')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
			    
			    				    			    
				    				    				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
				    
			    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

		elseif(Mode=='T E R M I N A T E D')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
			    
                   
                    								    				    				Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.new'Black'.Color;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10,0.5,10);
					EndSize=Vector3.new(10,0.5,10);
					}
			    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

		elseif(Mode=='BROKEN')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
			    
			    				    			    
				    				    				Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
			    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-4*M.C(Sine/1)),M.R(-3.3),M.R(146.5)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1,0.95,-1)*CF.A(M.R(43.7-4*M.C(Sine/1)),M.R(-3.3),M.R(-146.5)),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

		elseif(Mode=='HAUNTED')then
			local wsVal = 6
			local Alpha = .2
			if(NeutralAnims)then
			    
			    				    			    
				    
				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				 
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-20-15*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(200+0*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='Onslaught')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
			    
			    			    
				    				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
			    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.4,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-2.4,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='ARSONIST')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
			    
			    			    
				    				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright orange'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
			    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='SUS')then
			local wsVal = 9
			local Alpha = .1
			if(NeutralAnims)then
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+1*M.C(Sine/4),0)*CF.A(M.R(0+5*M.S(Sine/20)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(1,0+.05*M.S(Sine/32),1)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-0-0*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-1,0+.05*M.S(Sine/32),1)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(0+0*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode==':joy:')then
			local wsVal = 9
			local Alpha = .1
			if(NeutralAnims)then
			    
			    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
			    
                    RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+1*M.C(Sine/4),0)*CF.A(M.R(0+5*M.S(Sine/20)),M.R(5),0),Alpha)
                    NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0+10*M.C(Sine/32),M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0+-10*M.C(Sine/32),M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='EXCALIBUR')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(10-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='MAYHEM')then
			local wsVal = 4
			local Alpha = .2
			if(NeutralAnims)then
			    
			    				    				    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
								    				    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.2,1,0.2);
					EndSize=Vector3.new(0.2,5,0.2);
				}
			    
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.05*M.S(Sine/32),0)*CF.A(-0.6,M.R(5+5*M.C(Sine/32)),M.R(-200-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(10-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='Ɇ₵ⱧØ')then
			local wsVal = 5
			local Alpha = .4
			if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.2*M.C(Sine/10),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/1),0)*CF.A(1.7,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end

			elseif(Mode=='Evicted')then
			local wsVal = 10
			local Alpha = .2
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5+5*M.C(Sine/32)),M.R(-15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.8,M.R(5-5*M.C(Sine/32)),M.R(15+5*M.C(Sine/32))),Alpha)
			end
			

			elseif(Mode=='!CORRUPTION!')then
			local wsVal = 10
			local Alpha = .2
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-5-0.0*M.S(Sine/32)),M.R(-0),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,0+0.1*M.S(Sine/32),0.2)*CF.A(-0.7,M.R(6+2*M.C(Sine/32)),M.R(45-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0.0,0+0.1*M.S(Sine/32),0.2)*CF.A(-0.7,M.R(6-2*M.C(Sine/32)),M.R(-45-5*M.C(Sine/32))),Alpha)
			end
			
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.0-movement/23*M.C(Sine/wsVal)/2,(-.5+movement/23*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/23)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/23)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*3))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-0.0+movement/23*M.C(Sine/wsVal)/2,(-.5-movement/23*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/23)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/23)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*3))),Alpha)
end

elseif(Mode=='!PURITY!')then
			local wsVal = 10
			local Alpha = .2
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.2+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-20-0.2*M.S(Sine/32)),M.R(-15),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.7,-0.7+.1*M.S(Sine/32),-0.6)*CF.A(1.2,M.R(2+0*M.C(Sine/32)),M.R(65+.2*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.8,-0.4+.1*M.S(Sine/32),-0.5)*CF.A(2.2,M.R(3-0*M.C(Sine/32)),M.R(-65+.2*M.C(Sine/32))),Alpha)
			end
			
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-0.0-movement/23*M.C(Sine/wsVal)/2,(-.5+movement/23*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/23)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/23)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*3))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-0.0+movement/23*M.C(Sine/wsVal)/2,(-.5-movement/23*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/23)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/23)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*3))),Alpha)
end

elseif(Mode=='Cautious')then
			local wsVal = 8
			local Alpha = .2
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0.0+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(7-0.2*M.S(Sine/32)),M.R(-0),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.6,M.R(35+0*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.6,M.R(-35-0*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
end




								elseif(Mode=='4TH DIMENSION')then
				local Alpha = .1
				if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+2*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/32)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/32)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.2*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(-10)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-45),0,M.R(10)),Alpha)
				end
			
			elseif(Mode=='BURN!')then
local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
			
								elseif(Mode=='E̶̠̰͕͔͂̐̓̾Ņ̷̢̗̖̰̗̤̘̈́̅̿̑Ḓ̶͍̖̗͇̞͓͈͕̌͂̍͗́͗͑̿͊͝ͅĻ̸̨̥̼̳̖̟͗̅̍̔͗̀̉̆͌̍E̴̘̝̘̻̞͗̂͒͛͊̀͘͝S̷͖̯̳̲̲͛͒̓͊Ş̷̩͇̣͙̩͓̺̎ͅ ̷̢͙̹͙̀̽͑̊̇̚̚͠S̷̡̱̠̳̻̖̳̻̉͌͋̒͌̔́I̴̢̼͈̩͛͑̚L̷̡͔̰̩̺̱͌͆́̓̋̆̓̈͘E̶̡͇̽̾͜N̷̛̼̺̈́̿̑̀͛͑̓͠͝C̴͍͔̆͊͋̅̕͜Ē̸̛̯͔̥̜̺͆')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
				    														GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,2,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),10+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='FADING')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
																elseif(Mode=='OVERDRIVE')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='SHATTERED')then
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,5,0),
Size = Vector3.new(0.3,0.3,0.3),
EndSize = Vector3.new(0.3,0.3,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 2,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-10,10),-4,(math.random(-10,10))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,7,0),
Size = Vector3.new(0.5,0,0.5),
EndSize = Vector3.new(0.3,10,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
												elseif(Mode=='₴₱ØØ₭ł₮Ɏ₴')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
												elseif(Mode=='E0RR0R')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 			    	LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(-1,0,M.R(-7+5*M.S(Sine/32))),Alpha)
  			    	RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(-1,0,M.R(7-5*M.S(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='CURED')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),10+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
								elseif(Mode=='UNMERCIFUL')then
local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(2, 2, 2),
EndSize = Vector3.new(2, 2,2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.4,
})
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),1+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='Relax')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='PSYCHO')then
								    
								    										    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
								    
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
												elseif(Mode=='BANISHED')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
					}
					
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				end
				
																elseif(Mode=='INFINITE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
					
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				
																				elseif(Mode=='DIMENSIONAL')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				
								GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
												GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				
				GotEffect{
					Lifetime=0.5;
					Mesh='Ring';
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0.5};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(0.5,0.5,0.5);
				}	
				    
					
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
							elseif(Mode=='SINGULARITY')then
				local Alpha = .1
				
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,5+.4*M.C(Sine/32),0)*CF.A(M.R(50+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
    				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(100-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0.5,M.R(-9),0.3),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-9),-0.5),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
																elseif(Mode=='90s')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				
				
																				elseif(Mode=='corrupted')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    
				    
				    				    
				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0+music.PlaybackLoudness/100,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0-music.PlaybackLoudness/100,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0-music.PlaybackLoudness/100) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0+music.PlaybackLoudness/100) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})


--2nd Layer Break--
				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0+music.PlaybackLoudness/100,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0-music.PlaybackLoudness/100,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0-music.PlaybackLoudness/100) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0+music.PlaybackLoudness/100) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0, 0.01, 0),
EndSize = Vector3.new(0+music.PlaybackLoudness/100, 0, 0+music.PlaybackLoudness/100),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    
				    
				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-30+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='EXECUTION')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='Corroded')then
				local Alpha = .1
				if(NeutralAnims)then


				    								    																		    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Grey'.Color;
Material = Enum.Material.CorrodedMetal,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-35+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1,0.95,-1)*CF.A(M.R(43.4-40*M.C(Sine/math.random(1,15))),M.R(-3.3-40*M.C(Sine/math.random(1,15))),M.R(146.5)),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.2*M.S(Sine/32),0)*CF.A(-0.3,M.R(5-5*M.C(Sine/32)),M.R(10+10*M.C(Sine/32))),Alpha)
  			    						if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5,M.R(15),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.4,M.R(-15),0),Alpha)
				end
				
																																elseif(Mode=='totally real immortality lord')then
				local Alpha = .1
				if(NeutralAnims)then

					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(-20+1*M.S(Sine/64)),M.R(10),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+0*M.S(Sine/32),0)*CF.A(-0.4,M.R(5+5*M.C(Sine/32)),M.R(-15-10*M.C(Sine/35))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+0*M.S(Sine/32),0)*CF.A(-0,M.R(5-5*M.C(Sine/32)),M.R(0+0*M.C(Sine/32))),Alpha)
  			    						if(M.RNG(1,45)==1)then
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
					else
						NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
					end
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.5,M.R(15),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.2*M.C(Sine/32),0)*CF.A(-0.4,M.R(-15),0),Alpha)
				end
				
																												elseif(Mode=='Wasteland')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
								
																								elseif(Mode=='My Return')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='EXPLOITED')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='STEAMPUNK')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='Studio')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0.4)*CF.A(3.4,M.R(5+5*M.C(Sine/32)),M.R(70-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(0.6,M.R(5-5*M.C(Sine/32)),M.R(-80+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='HACKER101')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='RELAXED')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='SPEED')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='STORM')then
				local Alpha = .1
				if(NeutralAnims)then


				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='IMPERFECTION')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																											elseif(Mode=='MALWARE')then
				local Alpha = .1
				if(NeutralAnims)then

				    				    																							Effect{
				Lifetime=0.5;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-20,20),math.random(-20,20),math.random(-20,20)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(2,2,2);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='ANARCHY')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='Immortal')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='CORPSE')then
				local Alpha = .1
				if(NeutralAnims)then

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='[ HI ]')then
				local Alpha = .1
				if(NeutralAnims)then

				    				    				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='Flouressent')then
				local Alpha = .1
				if(NeutralAnims)then

				    				Effect({
Color = Color3.fromRGB(100, 100, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																												elseif(Mode=='Ruptured')then
				local Alpha = .1
				if(NeutralAnims)then

				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(0, 0, 0);
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4+music.PlaybackLoudness/50,0.2,4+music.PlaybackLoudness/50);
					EndSize=Vector3.new(3+music.PlaybackLoudness/50,0.2,3+music.PlaybackLoudness/50);
					}
					
									    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(40, 0, 0);
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/50,0.5,3+music.PlaybackLoudness/50);
					EndSize=Vector3.new(3+music.PlaybackLoudness/50,0.5,3+music.PlaybackLoudness/50);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+1*M.C(Sine/39),2+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.1*M.S(Sine/32),-0.5)*CF.A(1,M.R(5+5*M.C(Sine/32)),M.R(80-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																								elseif(Mode=='OVERRIDDEN')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(40, 40, 40),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='TRANSCENDANCE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4+music.PlaybackLoudness/3,0.2,4+music.PlaybackLoudness/3);
					EndSize=Vector3.new(3+music.PlaybackLoudness/3,0.2,3+music.PlaybackLoudness/3);
					}
					
									    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.new("Gold");
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/3,0.5,3+music.PlaybackLoudness/3);
					EndSize=Vector3.new(3+music.PlaybackLoudness/3,0.5,3+music.PlaybackLoudness/3);
					}
				    

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='PREHISTORIC')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(4+music.PlaybackLoudness/100,0.2,4+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.2,3+music.PlaybackLoudness/100);
					}
					
									    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = Color3.fromRGB(40, 0, 60);
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='GALACTIC')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(100, 0, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,7,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					}
				
									    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
				GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Royal purple'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),10+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='labyrinth')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='Ω')then
				local Alpha = .1
				if(NeutralAnims)then

				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='PERSERVERENCE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 255, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
                    LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.2+.2*M.S(Sine/32),-0.5)*CF.A(1.6,M.R(5+5*M.C(Sine/32)),M.R(90-5*M.C(Sine/32))),Alpha)
                    RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.2*M.S(Sine/32),-0.5)*CF.A(0.4,M.R(5-5*M.C(Sine/32)),M.R(-70+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='ENTROPY')then
				local Alpha = .1
				if(NeutralAnims)then
				    

				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Dark blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
				
																								elseif(Mode=='ALIVE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
								    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Pastel light blue'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}    
				
								    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
				elseif(Mode=='RITUALISTIC')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    																							Effect{
				Lifetime=0.4;
					--Mesh={Type=Enum.MeshType.Sphere};
					Part = 'Sword',
					Color=PrimaryColor;
					CFrame = Root.CFrame* CF.N(math.random(-20,20),-3,math.random(-20,20)) * CF.A(1.5,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=V3.N(0.8,2.5,6.8);
					EndSize=V3.N(0.8,2.5,16);
					}
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='MERCILESS')then
				local Alpha = .1
				if(NeutralAnims)then
				
				
																							Effect{
				Lifetime=0.4;
					--Mesh={Type=Enum.MeshType.Sphere};
					Part = 'Sword',
					Color=PrimaryColor;
					CFrame = Root.CFrame* CF.N(math.random(-20,20),-3,math.random(-20,20)) * CF.A(1.5,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=V3.N(0.8,2.5,6.8);
					EndSize=V3.N(0.8,2.5,16);
					}
					
									    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/40,0.5,3+music.PlaybackLoudness/40);
					EndSize=Vector3.new(3+music.PlaybackLoudness/40,0.5,3+music.PlaybackLoudness/40);
					}

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='BEYOND')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 0, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='LUNAR')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(150, 150, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Pastel light blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    				    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
								    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Pastel light blue'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}


				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
												elseif(Mode=='SIMULATION')then
				local Alpha = .1
				if(NeutralAnims)then
				    
Effect({
Color = Color3.fromRGB(0, 100, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    				    							    			    				GotEffect{
					Lifetime=.1;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame=Torso.CFrame*CF.N(0,1.5,-5)*CF.A(M.RRNG(0,0),M.RRNG(0,0),M.RRNG(0,0));
					Color=BrickColor.new'Camo'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(10,10,0.5);
				}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='Mystical')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 100, 100),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Med. reddish violet'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				
				GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Med. reddish violet'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,1,1);
					EndSize=Vector3.new(1.3,1.3,1.3);
				}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='Blaze')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright orange'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																												elseif(Mode=='Ancient')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright orange'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='SCARRED')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/40,0.5,3+music.PlaybackLoudness/40);
					EndSize=Vector3.new(3+music.PlaybackLoudness/40,0.5,3+music.PlaybackLoudness/40);
					}
				    
				    								    GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame=Head.CFrame*CF.N(0.2,0.3,-0.7)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0.2,0);
					EndSize=Vector3.new(0.2,4,0.2);
				}	
				
				

																			Effect{
				Lifetime=0.1;
					Mesh={Type=Enum.MeshType.Sphere};
					Color=PrimaryColor;
					CFrame = Root.CFrame* CF.N(math.random(-20,20),-3,math.random(-20,20)) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,10+music.PlaybackLoudness/100,1);
					EndSize=Vector3.new(1,10+music.PlaybackLoudness/100,1);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='ACCENTION')then
				local Alpha = .1
				if(NeutralAnims)then
				    GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.4,-0.56)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(1,0.3,1);
				}		
				
								    GotEffect{
					Lifetime=0.3;
					Mesh={Type=Enum.MeshType.Brick};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={0.3,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.6,0.2,0.6);
					EndSize=Vector3.new(0.2,15,0.2);
				}	
				
												    GotEffect{
					Lifetime=0.0001;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=Torso.CFrame*CF.N(0,0.2,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'White'.Color;
					Transparency={0.8,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(8,8,8);
					EndSize=Vector3.new(8,8,8);
				}	
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='deterioration')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})


				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
				
																								elseif(Mode=='ABNORMALITY')then
				local Alpha = .1
				if(NeutralAnims)then
		    
				    							    				    				Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.3,
})

														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					}
					
																			Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Brick};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1+music.PlaybackLoudness/100,0.5,1+music.PlaybackLoudness/100);
					EndSize=Vector3.new(1+music.PlaybackLoudness/100,0.5,1+music.PlaybackLoudness/100);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																												elseif(Mode=='PROBLEMATIC')then
				local Alpha = .1
				if(NeutralAnims)then
		    

														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					}
					

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='Malfunction')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Camo'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

																							Effect{
				Lifetime=0.5;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
    				CFrame = Torso.CFrame* CF.N(math.random(-20,20),math.random(-20,20),math.random(-20,20)) * CF.A(0,M.R(0),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0,0,0);
					EndSize=Vector3.new(2,2,2);
					}

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='broom')then
				local Alpha = .1
				if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.5+0*M.C(Sine/32),4+1*M.C(Sine/25),0+0*M.S(Sine/32))*CF.A(M.R(-50+5*M.S(Sine/32)),0,0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.4,-1+.05*M.S(Sine/32),-0.7)*CF.A(0.9,M.R(5+5*M.C(Sine/32)),M.R(90-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.4,0+.05*M.S(Sine/32),0.8)*CF.A(0.5,M.R(5-5*M.C(Sine/32)),M.R(-10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.2-.1*M.C(Sine/32),-1.0)*CF.A(-0.2-.2*M.C(Sine/32),M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.2-.05*M.C(Sine/32),-1.0)*CF.A(-0.6-.2*M.C(Sine/32),M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='SCP 3857 - 1')then
				local Alpha = .1
				if(NeutralAnims)then
				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
Size = Vector3.new(0, 0.01, 3*music.PlaybackLoudness/40),
EndSize = Vector3.new(0-music.PlaybackLoudness/40, 0, 0-music.PlaybackLoudness/40),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
Size = Vector3.new(3*music.PlaybackLoudness/40, 0.01, 0),
EndSize = Vector3.new(0-music.PlaybackLoudness/40, 0, 0-music.PlaybackLoudness/40),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/32)),M.R(10),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(-0.6+0*M.S(Sine/32),-1.2+.05*M.S(Sine/32),0.1+-0.2*M.C(Sine/32))*CF.A(1.0+0.2*M.C(Sine/32),M.R(5+5*M.C(Sine/32)),M.R(15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0.2,2.7+.05*M.S(Sine/32),-1)*CF.A(3+0.2*M.C(Sine/32),M.R(5-5*M.C(Sine/32)),M.R(-5+5*M.C(Sine/32))),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-100*M.S(Sine/1)),M.R(-5+100*M.S(Sine/1)),0+100*M.S(Sine/1)),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-0.8,2-.05*M.C(Sine/32),0+0*M.C(Sine/32))*CF.A(-0.7+0.2*M.C(Sine/32),M.R(-5),-0.5+0.1*M.C(Sine/32)),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(1,2-.05*M.C(Sine/32),0+0*M.C(Sine/32))*CF.A(2.7+0*M.C(Sine/32),M.R(-5),0.1+0*M.C(Sine/32)),Alpha)
				end
				
																												elseif(Mode=='Amalgamate')then
				local Alpha = .1
				if(NeutralAnims)then
				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
					
																			Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Brick};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1+music.PlaybackLoudness/80,0.5,1+music.PlaybackLoudness/80);
					EndSize=Vector3.new(1+music.PlaybackLoudness/80,0.5,1+music.PlaybackLoudness/80);
					}

				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/32)),M.R(10),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.2,-1.8+.2*M.S(Sine/32),0.5)*CF.A(-0.4,M.R(5+5*M.C(Sine/32)),M.R(5-0*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0.5,-1.2+.2*M.S(Sine/32),-0.4)*CF.A(2.4,M.R(5-5*M.C(Sine/32)),M.R(5+0*M.C(Sine/32))),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-100*M.S(Sine/1)),M.R(-5+100*M.S(Sine/1)),0+100*M.S(Sine/1)),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(LSC0*CF.N(0.1,0.5+.2*M.S(Sine/32),-0.4)*CF.A(-0.4,M.R(5+5*M.C(Sine/32)),M.R(5-0*M.C(Sine/32))),Alpha)
					RH.C0 = RH.C0:lerp(RSC0*CF.N(0,0.5+.2*M.S(Sine/32),0.3)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(15+0*M.C(Sine/32))),Alpha)
				end
				
													elseif(Mode=='SCP 3857 - 2')then
				local Alpha = .1
				if(NeutralAnims)then
				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
					
																			Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Brick};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1+music.PlaybackLoudness/80,0.5,1+music.PlaybackLoudness/80);
					EndSize=Vector3.new(1+music.PlaybackLoudness/80,0.5,1+music.PlaybackLoudness/80);
					}

				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+1*M.C(Sine/32),0)*CF.A(M.R(-20+8*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.9,-1.6+.05*M.S(Sine/32),-0.5)*CF.A(1.9,M.R(5+5*M.C(Sine/32)),M.R(15-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.9,-1.6+.05*M.S(Sine/32),-0.5)*CF.A(1.5,M.R(5-5*M.C(Sine/32)),M.R(-15+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0.4,0.2-.05*M.C(Sine/32),-1.6)*CF.A(1.3,M.R(-5),1.0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),-1.6)*CF.A(0.4,M.R(-5),-0.2),Alpha)
				end
				
				elseif(Mode=='ISOLATION')then
				local Alpha = .1
				if(NeutralAnims)then
				    								    				    				Effect({
Color = BrickColor.new'Dark blue'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.new'Really black'.Color;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10,0.5,10);
					EndSize=Vector3.new(10,0.5,10);
					}

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
								
																				elseif(Mode=='K A R M A')then
				local Alpha = .1
				if(NeutralAnims)then
				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
Size = Vector3.new(0, 0.01, 3*music.PlaybackLoudness/40),
EndSize = Vector3.new(0-music.PlaybackLoudness/40, 0, 0-music.PlaybackLoudness/40),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
Size = Vector3.new(3*music.PlaybackLoudness/40, 0.01, 0),
EndSize = Vector3.new(0-music.PlaybackLoudness/40, 0, 0-music.PlaybackLoudness/40),
Transparency = NumberRange.new(0,0),
Lifetime = 0.2,
})

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='VISUALIZER')then
				local Alpha = .1
				if(NeutralAnims)then
				    
														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(13+music.PlaybackLoudness/100,0.5,13+music.PlaybackLoudness/100);
					EndSize=Vector3.new(13+music.PlaybackLoudness/100,0.5,13+music.PlaybackLoudness/100);
					}
					
																								Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Brick};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10+music.PlaybackLoudness/100,0.5,10+music.PlaybackLoudness/100);
					EndSize=Vector3.new(10+music.PlaybackLoudness/100,0.5,10+music.PlaybackLoudness/100);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='Darkness')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='ALTERATION')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 255, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='DISTORTION')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				    				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(-1,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(-1,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.06, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    																	    local HCF = Root.CFrame * CF.N(math.random(-10,20),-4,(math.random(-10,10))) * CF.A(M.R(math.random(-0,0)),M.R(math.random(-0,0)),M.R(math.random(-0,0)))
Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0,0,0),
EndSize = Vector3.new(0.2,1,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
				  
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='disturbance')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				    				Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.13, 0.06, 0.13),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-0,0)),M.R(math.random(-0,0)),M.R(math.random(-0,0)))
Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,5,0),
Size = Vector3.new(1,1,1),
EndSize = Vector3.new(1,1,1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    																	    local HCF = Root.CFrame * CF.N(math.random(-10,20),-4,(math.random(-10,10))) * CF.A(M.R(math.random(-0,0)),M.R(math.random(-0,0)),M.R(math.random(-0,0)))
Effect({
Color = PrimaryColor;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0,0,0),
EndSize = Vector3.new(0.2,1,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='lost')then
				local Alpha = .1
				if(NeutralAnims)then
				    								    				    				Effect({
Color = BrickColor.new'Lilac'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = BrickColor.new'Black'.Color;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(10,0.5,10);
					EndSize=Vector3.new(10,0.5,10);
					}
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='IMMORTALITY')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = BrickColor.new'Grey'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='Solar')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					EndSize=Vector3.new(3+music.PlaybackLoudness/100,0.5,3+music.PlaybackLoudness/100);
					}
					
																			Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Brick};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-0,0)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1+music.PlaybackLoudness/100,0.5,1+music.PlaybackLoudness/100);
					EndSize=Vector3.new(1+music.PlaybackLoudness/100,0.5,1+music.PlaybackLoudness/100);
					}
				    
				    				Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='OBLITERATION')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='ETERNAL')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 255, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='depleted')then
				local Alpha = .1
				if(NeutralAnims)then
				   				    				    
				    				Effect({
Color = Color3.fromRGB(170, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Maroon'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='Extinction')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash2",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.8, 0.01, 0.8),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='TORTURED')then
				local Alpha = .1
				if(NeutralAnims)then
				    				    
				    				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Dark grey'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,5,0),
Size = Vector3.new(0.3,0.3,0.3),
EndSize = Vector3.new(0.3,0.3,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 2,
})
				    
				    				    				Effect({
Color = Color3.fromRGB(100, 100, 100),
Material = Enum.Material.Neon,
Mesh = "Tornado2",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(30, 5, 30),
Transparency = NumberRange.new(0,1),
Lifetime = 0.3,
})
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='Untrustworthy')then
				local Alpha = .1
				if(NeutralAnims)then
				    
			
					GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.1,1,.1);
					EndSize=Vector3.new(.5,5,.5);
					}
					
										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.1,1,.1);
					EndSize=Vector3.new(.5,5,.5);
					}	    				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,5,0),
Size = Vector3.new(0.3,0.3,0.3),
EndSize = Vector3.new(0.3,0.3,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 2,
})

																	    local HCF = Root.CFrame * CF.N(math.random(-10,10),-4,(math.random(-10,10))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Maroon'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,7,0),
Size = Vector3.new(0.5,0,0.5),
EndSize = Vector3.new(0.3,10,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
								
																				elseif(Mode=='Omnipotent')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 255, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0.3),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(0+8*M.C(Sine/32)),M.R(-20-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(-0.5,M.R(10-8*M.C(Sine/32)),M.R(170+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end

				
																								elseif(Mode=='Collected')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 255, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.3,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+0.5*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(10),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.5,M.R(5+5*M.C(Sine/32)),M.R(10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.5,M.R(5-5*M.C(Sine/32)),M.R(-10+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(-1,0.2-0*M.C(Sine/32),-0.6)*CF.A(0,M.R(-5),1.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(1,0.2-0*M.C(Sine/32),-0.6)*CF.A(0,M.R(-5),-1.4),Alpha)
				end
				
																												elseif(Mode=='Ringed')then
				local Alpha = .1
				if(NeutralAnims)then
		    			    
				    				
																	    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh='Ring';
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(0.3,0.3,0.3),
EndSize = Vector3.new(0.3,0.3,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})

				    				Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})	    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='disfigured')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = Color3.fromRGB(100, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='Multiversal')then
				local Alpha = .1
				if(NeutralAnims)then
				    
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='HAZARDOUS')then
				local Alpha = .1
				if(NeutralAnims)then
				    				    
				    				Effect({
Color = Color3.fromRGB(186, 143, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,20,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,20,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='Mythical')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 100, 100),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='DREAM')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(-3,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(-3,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																							elseif(Mode=='Unresponsive')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
 
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='besmirch')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				Effect({
Color = Color3.fromRGB(217, 147, 72),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																								elseif(Mode=='A n g e l')then
				local Alpha = .1
				if(NeutralAnims)then
				    				Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.3,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,15,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-70+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),-0.1),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.5,M.R(-5),0.1),Alpha)
				end
				
																				elseif(Mode=='A b a N d O e D')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='S T O L E N')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    
				    
				    				    
				    				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-100,100),-4,(math.random(-100,100))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,100,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(4, 0.01, 4),
Transparency = NumberRange.new(0,1),
Lifetime = 0.9,
})
		
				    
 		    	RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.2+5.4*M.C(Sine/39),30+7.5*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/15)),M.R(-5+5*M.C(Sine/15)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='FORMALITY')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																								elseif(Mode=='FORMALITY')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='HOPELESS')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really red'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																								elseif(Mode=='decaying soul')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    
				    				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Brown'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,20,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    				    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Brown'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,20,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.4,
})
				    
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																								
				
																				elseif(Mode=='RADIANT')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    
				    				    				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,20,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

				    																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,10,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash2",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.6, 0.01, 0.6),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='MONSTROSITY')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				Effect({
Color = Color3.fromRGB(255, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='INCOMPREHENSIBLE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    
				    				    
				    																	    local HCF = Root.CFrame * CF.N(math.random(-50,50),-4,(math.random(-50,50))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Royal purple'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.3,20,0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = Color3.fromRGB(255, 0, 255),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.6, 0.01, 0.6),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='DREADED')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    										    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																		elseif(Mode=='Pneumonoultramicroscopicsilicovolcanoconiosis')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				    				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
					elseif(Mode=='BRILLIANCE')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(25-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
					elseif(Mode=='!Destiny!')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(25-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
					elseif(Mode=='EQUINOX')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(25-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				

				
																				elseif(Mode=='【Ｊｕｓｔｉｃｅ】')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,60+1*M.C(Sine/32),0)*CF.A(M.R(-60+1*M.S(Sine/64)),M.R(0),-0.0+-0.0*M.C(Sine/32)),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(30-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
					elseif(Mode=='【P u r e】')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,40+5*M.C(Sine/32),0)*CF.A(M.R(-60+1*M.S(Sine/64)),M.R(0),-0.0+-0.0*M.C(Sine/32)),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(30-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				elseif(Mode=='【P e r s e v e r a n c e】')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,30+5*M.C(Sine/32),0)*CF.A(M.R(-60+1*M.S(Sine/64)),M.R(0),-0.0+-0.0*M.C(Sine/32)),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(30-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				

				
																				elseif(Mode=='POWER')then
				local Alpha = .1
				if(NeutralAnims)then
			
Effect({
Color = Color3.fromRGB(255, 255, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.2, 0.01, 0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})	    
				    				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

					GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright yellow'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright yellow'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					

				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																								elseif(Mode=='HOLOGRAPHIC')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-30,30)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

					GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright blue'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Bright blue'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='THE TRUE ENDING')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='SOLITUDE')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='SCURRILITY')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='A N O M A L O U S')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    
Effect({
Color = Color3.fromRGB(0, 0, 0),
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='DETERMEND')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),7+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Catastrophe')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Calamity')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				Effect({
Color = BrickColor.new'Pink'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Pink'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Destiny')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																								elseif(Mode=='Cuboid')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    			    
				    				
																	    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(1,1,1),
EndSize = Vector3.new(1,1,1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.5,
})

				    				Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				
																				elseif(Mode=='FORCE')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='PULSAR')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Looped Error')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='APCOCLYPTIC')then
				local Alpha = .1
												    													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really red'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
																	GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Crimson'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='GENOCIDE')then
				local Alpha = .1
																								    
																				    												    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})	
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='PESTILENCE')then
				local Alpha = .1
										     local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Really black'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,3+1*M.C(Sine/32),0)*CF.A(M.R(60+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-150-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(150+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),-0.4),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.8,M.R(-5),0.4),Alpha)
				end
				
																				elseif(Mode=='BURNING BRAIN')then
				local Alpha = .1
				
										     local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='ACE-OF-SPADES')then
																				    
																				    												    local HCF = Root.CFrame * CF.N(math.random(-70,70),-4,(math.random(-70,70))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright yellow'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='WORMHOLE')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='???')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='TIME WARP')then
				local Alpha = .1
				if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,4+2.05*M.C(Sine/80),0)*CF.A(M.R(-0+10*M.S(Sine/32)),M.R(-0+999*M.C(Sine/80)),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-90-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(90+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0),Alpha)
				end
				
																elseif(Mode=='Deleterious')then
																			    
					GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(.0,0,.0);
					}
					
										GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(2,2,2);
					EndSize=Vector3.new(.0,0,.0);
					}
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(90+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.8)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
				end
				
																				elseif(Mode=='GREATSWORD')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,.4+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(124-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Nefarious')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Atomic Collisions')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				
				
																			elseif(Mode=='System X')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(10+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end	
				
																				elseif(Mode=='Abstraction')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
																				elseif(Mode=='Lightning Cannon')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
			    	LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(-1,0,M.R(-7+5*M.S(Sine/32))),Alpha)
  			    	RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(-1,0,M.R(7-5*M.S(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0.6-.1*M.C(Sine/32),-0.3)*CF.A(-0.2,M.R(20),-0.08),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.4-.1*M.C(Sine/32),-0.3)*CF.A(-0.3,M.R(-20),0.08),Alpha)
					else
				end
				
																				elseif(Mode=='UNSTABLE')then
 local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																								elseif(Mode=='R E M E M B E R E D')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-160-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(70-5*M.C(Sine/32)),M.R(75+2*M.C(Sine/1))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				
																				elseif(Mode=='SPEED OF LIGHT')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
			
																				elseif(Mode=='EXCALIBUR X')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5+5*M.C(Sine/1)),M.R(40-10*M.C(Sine/1))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(10-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end

				
																								elseif(Mode=='F0RG0TT3N')then
				local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,-0+.05*M.C(Sine/32),0)*CF.A(M.R(-40+5*M.S(Sine/64)),M.R(5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0.5,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(-150+5*M.C(Sine/32)),M.R(-75-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(150-5*M.C(Sine/32)),M.R(75+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='M A L I C E')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    				    														Effect{
				Lifetime=0.001;
					Mesh={Type=Enum.MeshType.Sphere};
                    Color = PrimaryColor;
					CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					EndSize=Vector3.new(3+music.PlaybackLoudness/80,0.5,3+music.PlaybackLoudness/80);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='HYPERSKIDDED')then
				local Alpha = .1
				if(NeutralAnims)then
				    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.random().Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,4,0.1),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = BrickColor.random().Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})

Effect({
Color = BrickColor.random().Color;
Material = Enum.Material.Neon,
Mesh = "Slash2",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.3, 0.01, 0.3),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='WITHERED')then
				local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+0*M.C(Sine/32),0)*CF.A(M.R(-40+1*M.S(Sine/64)),M.R(5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(1.5,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0.5,M.R(5-5*M.C(Sine/32)),M.R(30+5*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.7,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.8-.05*M.C(Sine/32),-0.7)*CF.A(-0.4,M.R(-5),0),Alpha)
				end
				
																				elseif(Mode=='SYSTEM_32')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    				    
				    				Effect({
Color = BrickColor.new'Maroon'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
																	    local HCF = Root.CFrame * CF.N(math.random(-20,20),-4,(math.random(-20,20))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(1,3,1),
EndSize = Vector3.new(0.2,10,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='ARCADE')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),10+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='FUTURE')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    			    				    			    
				    				    				Effect({
Color = BrickColor.new'Lilac'.Color;
Material = Enum.Material.Neon,
Mesh = "Slash1",
CFrame = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
EndPos = Root.CFrame* CF.N(0,-3,0) * CF.A(0,M.R(math.random(-180,180)),0),
Size = Vector3.new(0.01, 0.01, 0.01),
EndSize = Vector3.new(0.1, 0.01, 0.1),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='Euclidiean')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
																				elseif(Mode=='CRAZED')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
																elseif(Mode=='Liar X')then
																    

				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
    				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(100-2*M.S(Sine/36))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(-0.5,0.5+.05*M.S(Sine/32),0+.05)*CF.A(M.R(160),M.R(5-5*M.C(Sine/1)),M.R(-40+10*M.C(Sine/1))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
																elseif(Mode=='bored')then
				local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,1+0*M.C(Sine/32),-0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(20),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5+5*M.C(Sine/32)),M.R(-20-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.5,M.R(5-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(90+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
			    	RH.C0 = RH.C0:lerp(CF.N(0.4,.3,-0.8)*CF.A(M.R(30+3.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
				end
																elseif(Mode=='Inferno')then
																    
																    				    
												    local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Neon orange'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.1,7,0.1),
EndSize = Vector3.new(0.2,100,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
																    
																    				    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
					
									    						    						    															GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Neon orange'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(0.3,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
																				elseif(Mode=='Volcanic')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
																elseif(Mode=='Hydro')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='FOUND')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='DESTRUCTION')then
				local Alpha = .1
				
										     local HCF = Root.CFrame * CF.N(math.random(-40,40),-4,(math.random(-40,40))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Crimson'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,30,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,12,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				elseif(Mode=='Sub-Normal')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='ILLUSION')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
								elseif(Mode=='HYPNOTIC')then
				local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,10+2*M.C(Sine/32),0)*CF.A(M.R(20+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,-.2+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.3,-.2+.05*M.S(Sine/32),.1)*CF.A(M.R(-25),M.R(5-2.5*M.C(Sine/32)),M.R(-35+1.5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(-0.2,M.R(-5),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0.5-.05*M.C(Sine/32),-0.7)*CF.A(-0.3,M.R(-5),0),Alpha)
				end
				elseif(Mode=='Normal')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				elseif(Mode=='S P A C E T I M E')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    								    																		    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Dark blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    

				    
				    													GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Really black'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				
																	GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RLeg.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Dark blue'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(1,3,1);
					EndSize=Vector3.new(.1,1,.1);
					}
				    
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 			    	LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(-1,0,M.R(-7+5*M.S(Sine/32))),Alpha)
  			    	RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(-1,0,M.R(7-5*M.S(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
				
				
								elseif(Mode=='G A M I N G C H A I R')then
				local Alpha = .1
				if(NeutralAnims)then
				    
				    								    																		    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'White'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Sphere},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(.7,7,0.7),
EndSize = Vector3.new(0.2,6,0.2),
Transparency = NumberRange.new(0,1),
Lifetime = 0.2,
})
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,2+1*M.C(Sine/32),0)*CF.A(M.R(-10+1*M.S(Sine/64)),M.R(5),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.4,M.R(5+5*M.C(Sine/32)),M.R(-20-5*M.C(Sine/32))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(-0.4,M.R(5-5*M.C(Sine/32)),M.R(20+5*M.C(Sine/32))),Alpha)
				end
				if(legAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,1-.05*M.C(Sine/32),0)*CF.A(0.5,M.R(-5),-0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),-0.2)*CF.A(1.5,M.R(-5),0),Alpha)
				end

							    
							    
				
												elseif(Mode=='HYBRID')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
												elseif(Mode=='Fearless')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
		    		LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
		    		RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
			elseif(Mode=='Radioactivity')then
				local Alpha = .1
				if(NeutralAnims)then
 		    		RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.3+.4*M.C(Sine/39),2+.2*M.C(Sine/32),0)*CF.A(M.R(-56+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10+8*M.C(Sine/32)),M.R(-20-1*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,-0.12+.01*M.S(Sine/52),0)*CF.A(0,M.R(10-8*M.C(Sine/32)),M.R(20+1*M.C(Sine/32))),Alpha)
  			    	NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
					RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
				end
			else

				local wsVal = 4
				local Alpha = .2
				if(Mode=='MURDEROUS')then Change=.3 elseif(Mode=='The Big Black' or Mode=='Legendary')then Change=1 else Change=.5 end
				if(NeutralAnims)then
				    local HCF = Root.CFrame * CF.N(math.random(-30,30),-4,(math.random(-30,30))) * CF.A(M.R(math.random(-20,20)),M.R(math.random(-20,20)),M.R(math.random(-20,20)))
Effect({
Color = BrickColor.new'Bright blue'.Color;
Material = Enum.Material.Neon,
Mesh = {Type = Enum.MeshType.Brick},
CFrame = HCF,
EndPos = HCF* CF.N(0,10,0),
Size = Vector3.new(0.1,0,0.1),
EndSize = Vector3.new(0.4,10,0.4),
Transparency = NumberRange.new(0,1),
Lifetime = 1.3,
})
				    
				    
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+0*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0-5*M.S(Sine/58)),0,0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0.1)*CF.A(M.R(0+45*(movement/8)*M.S(Sine/wsVal))*forwardvelocity,0.1,-0.2),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0.1)*CF.A(M.R(0-45*(movement/8)*M.S(Sine/wsVal))*forwardvelocity,-0.1,0.2),Alpha)
				end
				if(legAnims)then 
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.0*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.0*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
					local footstepIds = {141491460,141491460}
					if(lhit and lhit.CanCollide and footstepSounds[lhit.Material])then
						if(lhit.Material==Enum.Material.Sand and lhit.Color.r*255>=160 and lhit.Color.g*255>=160 and lhit.Color.b*255>=160)then
							footstepIds[1] = footstepSounds[Enum.Material.Snow]
						else
							footstepIds[1] = footstepSounds[lhit.Material]
						end
					end
					
					

					if(rhit and rhit.CanCollide and footstepSounds[rhit.Material])then
						if(rhit.Material==Enum.Material.Sand and rhit.Color.r*255>=160 and rhit.Color.g*255>=160 and rhit.Color.b*255>=160)then
							footstepIds[2] = footstepSounds[Enum.Material.Snow]
						else
							footstepIds[2] = footstepSounds[rhit.Material]
						end
					end

					if(M.C(Sine/wsVal)/2>=.2 and footsound==0 and lhit)then
						local step = Part(Effects,lhit.Color,lhit.Material,V3.N(1,.1,1),CF.N(lpos),true,false)
						step.Transparency=(footstepIds[1]==footstepSounds[Enum.Material.Snow] and 0 or 1)
						local snd = Soond(step,footstepIds[1],M.RNG(80,100)/100,3,false,true,true)
						footsound=1
						S.Debris:AddItem(step,snd.TimeLength+2)
					elseif(M.C(Sine/wsVal)/2<=-.2 and footsound==1 and rhit)then
						local step = Part(Effects,rhit.Color,rhit.Material,V3.N(1,.1,1),CF.N(rpos),true,false)
						step.Transparency=(footstepIds[2]==footstepSounds[Enum.Material.Snow] and 0 or 1)
						local snd = Soond(step,footstepIds[2],M.RNG(80,100)/100,3,false,true,true)
						footsound=0
						S.Debris:AddItem(step,snd.TimeLength+2)
					end
				end
			end
		elseif(State == 'Jump')then
			local Alpha = .1
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			if(NeutralAnims)then
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			end
		elseif(State == 'Fall')then
			local Alpha = .1
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			if(NeutralAnims)then
				LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
			end
		elseif(State == 'Paralyzed')then
			local Alpha = .1
			if(NeutralAnims)then
				LS.C0 = LS.C0:lerp(LSC0,Alpha)
				RS.C0 = RS.C0:lerp(RSC0,Alpha)
				RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0,Alpha)
				RH.C0 = RH.C0:lerp(RHC0,Alpha)
			end
		elseif(State == 'Sit')then

		end
		if(data.User==data.Local)then
			local syncStuff={
				NeutralAnims;
				legAnims;
				{NK.C0,RJ.C0,RH.C0,RS.C0,LH.C0,LS.C0};
				{NK.C1,RJ.C1,RH.C1,RS.C1,LH.C1,LS.C1};
				Sine;
				movement;
				walking;	
				Change;
				--// OPTIONAL SYNC \\--
				MusicMode;
				(music and music.TimePosition or 0);
				(music and music.Pitch or 1);
				WingSine;
				getMode('Troubadour');
				Mode;
				hue;
			}
		end
		
		-- Glitcher is Pneumonoultramicroscopicsilicovolcanoconiosis
		-- print("welcoem")
		-- 9i need 19k lines!!
		
		
		
		
	end--End Of Script -- v10 part 2 Of SGw

